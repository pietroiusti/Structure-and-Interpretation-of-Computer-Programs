#+title: Structure and Interpretation of Computer Programs
#+subtitle: Personal notes
#+author: Giulio Pietroiusti
#+options: num:nil


Memorably, computer science --- the subject matter of the book --- is
presented as a non-science whose signficance has little to do with
computers (see also the [[https://youtu.be/-J_xL4IGhJA?list=PLE18841CABEA24090&t=26][lecture]]). Just as memorably, computer science
is presented as a branch of /epistemology/, that is, the study of
/knowledge/ (which, tipically, is considered part of /philosophy/). In
particular, computer science is /procedural/ epistemology. We deal
here with the systematization of imperative, /how-to/, knowledge, as
opposed to ``declarative'' knowledge. The computer scientist deals,
indeed, with a complexity that resembles that of the human mind ---
notice the epigraph from Locke. Much of his job is dominating the
``intellectual complexity'' of software systems.

Here is a bullet-point summary up to section 1.1 (included) and my
solutions of the exercises. As expected these first pages present
fundamental concepts and building blocks.

* Foreword (by Alan J. Perlis)
- The subject matter of this book involves three foci of phenomena
  - the human mind;
  - collection of computer programs;
  - the computer.

- /Idioms/: ``standard program structures of whose corrected we have
  becamse sure''.

- /Algorithms/: programs that ``perform a precise mathematical
  function such as sorting or finding the maximum of a sequence of
  numbers , determining primality, or finding the square root.''

#+begin_quote
A programmer should acquire good algorithms and idioms. (xiii)
#+end_quote

* Preface to the First Edition
- The authors express two major concerns:
  1. They want to establish the idea ``idea that a computer language
     is not just a way of getting a computer to perform operations but
     rather that it is /a novel formal medium for expressing ideas
     about methodology/'' (my emphasis).

  2. The essential material of interest here are the /techniques used
     to/ /control the intellectual complexity of large software
     systems/; not: matters of syntax of particular languages, clever
     algorithms in special contexts, mathematical analysis of
     algorithms, or foundations of computing.

- Computer science is not science and its significance has very little
  to do with computers.

- /Procedural Epistemology/: ``the study of the structure of knowledge
  from an imperative point of view, as opposed to a more declarative
  point of view...''.

* 1. Building Abstractions with Procedures
- A /Computational process/ is an abstract thing that inhabits a computer.

- /Data/ are other abstract things manipulated by processes.

- A /program/ is a pattern of rules that direct the evolution of a process.

- Programs are composed from expressions in /programming languages/.

- Good design is /modular/.

- Lisp /interpreter/: ``a machine that carries out processes described
  in the Lisp language''.

- ``...Lisp descriptions of processes, called /procedures/, can
  themselves be represented and manipulated as Lisp data. The
  importance of this is that there are powerful program-design
  techniques that rely on the ability to blur the traditional
  distinction between ``passive'' data and ``active'' processes.''

** The elements of programming
- A powerful programming language enables us to describe processes and
  organize our ideas about them, not merely to instruct a computer to
  perform some operations.

- To organize our ideas about processes well we must be able to
  combine simple ideas to give life to more complex ones. We can do so
  through three mechanisms provided by a powerful programming
  language:
  - *Primitive expressions*
  - *Means of combinations*
  - *Means of abstractions*

*** Expressions
- ``You type an /expression/, and the interpreter responds by
  displaying the result of its /evaluating/ that expression.''

- /Combinations/;
- /Operator/;
- /Operands/;
- /Arguments/.

- /read-eval-print loop/: ``the intepreter always operates in the same
  basic cycle: It reads an expression from the terminal, evaluates the
  expression, and prints the result''.

*** Naming and the Environment
- A programming language provides means to use names to refer to
  computational object. ``We say that the name identifies a /variable/
  whose /value/ is the object.''

- `` ~Define~ is our language's simples means of abstraction.

- /Environment/.

*** Evaluating Combinations
- The interpreter evaluates combinations by following a procedure:
  #+begin_quote
  - To evaluate a combination, do the following:
    1. Evaluate the subexpressions of the combination;
    2. Apply the procedure that is the value of the leftmost
       subexpression (the operator) to the arguments that are the values
       of the other subexpressions (the operands).
  #+end_quote

- The evaluation rule is /recursive/.

- We can view the evaluation in terms of a tree (See p. 10).

  [[./figure1-1.gif]]

- Tree accumulation.

- /Special forms/ constitute exceptions to the general evaluation
  rule. ~Define~ is a special form.

*** Compound Procedures
- /Procedure definitions/: a much more powerful abstraction technique.

- /Compound procedures/.

*** The Substitution Model for Procedure Application
- Application process for compound procedures:
  - To apply a compound procedure to arguments, evaluate the body of
    the procedure with each formal parameter replaced by the
    corresponding argument.

- /Substitution model/ for procedure application: a model to determine
  the ``meaning'' of procedure application (in this chapter);
  - This is not how interpreters actually work;
  - The substitution model is the first of a sequence of increasingly
    elaborated models presented in this book of how intepreters
    work. Chapter 5 will present a complete implemetation of an
    interpreter an compiler.

- Lisp uses /applicative-order/ evaluation: the interpreter evaluates
  the operator and the operands and then applies the resulting
  procedure to the resulting arguments --- the procedure (followed by
  the intepreter to evaluate a combination) described above.

- An alternative evaluation mode: /normal-order/ evaluation.

*** Conditional Expressions and Predicates
- ~cond~
- ~if~
- ~and~
- ~or~
- ~not~
*** Exercise 1.1
Exercise:
#+begin_quote
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence
is to be evaluated in the order in which it is presented.

#+begin_src scheme
  10
  (+ 5 3 4)
  (- 9 1)
  (/ 6 2)
  (+ (* 2 4) (- 4 6))
  (define a 3)
  (define b (+ a 1))
  (+ a b (* a b))
  (= a b)
  (if (and (> b a) (< b (* a b)))
      b
      a)
  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  (+ 2 (if (> b a) b a))
  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
#+end_src
#+end_quote

Answer:
#+begin_src elisp
  10
  ;; 10

  (+ 5 3 4)
  ;; 12

  (- 9 1)
  ;; 8

  (/ 6 2)
  ;; 3

  (+ (* 2 4) (- 4 6))
  ;; 6
#+end_src

The authors, p. 8 fn. 8, say that the response to evaluating
definitions is ``highly implementation-dependent''.

I gather that Scheme's ~define~, when used for variables, is
equivalent for Elisp's ~setq~.

#+begin_src elisp
  (setq a 3)
  ;; 3

  (setq b (+ a 1))
  ;; 4

  (+ a b (* a b))
  ;; 19
#+end_src

I gather that Scheme's ~=~, when used for variables, is
equivalent for Elisp's ~eq~.

#+begin_src elisp
  (eq a b)
  ;; nil

  (if (and (> b a) (< b (* a b)))
      b
    a)
  ;; 4

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  ;; 16

  (+ 2 (if (> b a) b a))
  ;; 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
  ;; 16
#+end_src
*** Exercise 1.2
Exercise:
#+begin_quote
Translate the following expression into prefix form

$\frac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3(6 - 2)(2 - 7)}$
#+end_quote

Answer:
#+begin_src elisp
  (/ (+ 5
        4
        (- 2
           (- 3
              (+ 6
                 (/ 4 5)))))
     (* 3
        (- 6 2)
        (- 2 7)))
#+end_src
*** Exercise 1.3
Exercise:
#+begin_quote
Define a procedure that takes three numbers as arguments and returns
the sum of the squares of the two larger numbers.
#+end_quote

Answer:

This was my first solution:
#+begin_src emacs-lisp
  (defun foo (a b c)
    (+ (square (if (> a b) a b))
       (square (if (> c
                      (if (> a b) b a))
                   c
                 (if (> a b) b a)))))
#+end_src

That works, although it is not ideal, because the combination ~(> a
b)~ is evaluated three times...
*** Exercise 1.4
Exercise:
#+begin_quote
Observe that our model of evaluation allows for combinations whose
operators are compound expressions. Use this observation to describe
the behavior of the following procedure:

#+begin_src scheme
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+end_src
#+end_quote

Answer:

Behavior: If ~b~ is greater than 0, then apply ~+~ to ~a~ and ~b~,
that is, add ~b~ to ~a~. Otherwise, apply ~-~ to ~a~ and ~b~, that is,
to subtract ~b~ from ~a~.

But subtracting a negative number, means adding it!  So, behavior: Add
the absolute value of ~b~ to ~a~.
*** Exercise 1.5
Exercise:

#+begin_quote
Ben Bitdiddle has invented a test to determine whether the interpreter
he is faced with is using applicative-order evaluation or normal-order
evaluation. He defines the following two procedures:

#+begin_src scheme
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
        0
        y))
#+end_src

Then he evaluates the expression

#+begin_src scheme
  (test 0 (p))
#+end_src

What behavior will Ben observe with an interpreter that uses
applicative-order evaluation? What behavior will he observe with an
interpreter that uses normal-order evaluation? Explain your
answer. (Assume that the evaluation rule for the special form if is
the same whether the interpreter is using normal or applicative order:
The predicate expression is evaluated first, and the result determines
whether to evaluate the consequent or the alternative expression.)
#+end_quote

Answer:

In the case of applicative-order evaluation, ``the interpreter first
evaluates the operator and operands and then applies the resulting
procedure to the resulting arguments'' (p. 16). This means that the
interpreter will evaluate ~test~, then ~0~ and then ~(p)~. ~test~
evaluates to a procedure. ~0~ evaluates to ~0~. But ~(p)~ evaluates to
~(p)~, which evaluates to ~(p)~, which evaluates to (p)', which... /ad
infinitum/. So, the interpreter enters an infinite evaluation; it will
never be able to apply the procedure denoted by ~test~, because it
will never be able to compute the second argument.

In the case of normal-order evaluation, operands are not evaluated
until their values are needed. ~(test 0 (p))~ would be turned into ~0~
and then evaluated. And '0' evaluates to 0.
*** 1.1.7 Example: Square Roots by Newton’s Method
- Procedures are analogous to mathematical functions: ``[t]hey specify a
  value that is determined by one or more parameters''. (21-22)

- However, procedures are different from mathematical functions in
  some respects. A mathematical function can tell us, say, whether a
  certain number is the square root of ~x~ or not. That, however, does
  not describe a /procedure/. It does not tell us /how to find/ the
  square root of ~x~.

- More generally, mathematics is usually concerned with ``declarative
  knowledge'', whereas computer science is concerned with ``imperative
  knowledge''.

- Iteration can be accomplished by calling a procedure. We don't need
  any looping construct.
*** Exercise 1.6
Exercise:

#+begin_quote
Alyssa P. Hacker doesn't see why ~if~ needs to be provided as a
special form. ``Why can't I just define it as an ordinary procedure in
terms of ~cond~?'' she asks. Alyssa's friend Eva Lu Ator claims this
can indeed be done, and she defines a new version of ~if~:

#+begin_src scheme
  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))
#+end_src

Eva demonstrates the program for Alyssa:

#+begin_src scheme
  (new-if (= 2 3) 0 5)
  5
#+end_src

#+begin_src scheme
  (new-if (= 1 1) 0 5)
  0
#+end_src

Delighted, Alyssa uses ~new-if~ to rewrite the square-root program:

#+begin_src scheme
  (define (sqrt-iter guess x)
    (new-if (good-enough? guess x)
            guess
            (sqrt-iter (improve guess x)
                       x)))
#+end_src

What happens when Alyssa attempts to use this to compute square roots? Explain.
#+end_quote

Answer:

~cond~ is a /special form/. ~if~, too, is a special form. ~new-if~,
instead, is not a special form. It is an ordinary /combination/.

Now, the evaluation of a combination entails the evaluation of both
the /operator/ and the /operands/. With Eva's ~new-if~, then,
~sqrt-iter~ calls itself /ad infinitum/ and a stack overflow occurs.

In fact, if we replace the ~new-if~ --- a combination --- with the
~cond~ --- a special form --- it would evaluate to, then things will
work as originally intended.
*** Exercise 1.7
#+begin_quote
The ~good-enough?~ test used in computing square roots will not be
very effective for finding the square roots of very small
numbers. Also, in real computers, arithmetic operations are almost
always performed with limited precision. This makes our test
inadequate for very large numbers. Explain these statements, with
examples showing how the test fails for small and large numbers. An
alternative strategy for implementing ~good-enough?~ is to watch how
guess changes from one iteration to the next and to stop when the
change is a very small fraction of the guess. Design a square-root
procedure that uses this kind of end test. Does this work better for
small and large numbers?
#+end_quote

Answer:

This is a pretty small number: $0.00025$. It's square root is
$\sqrt{0.00025} = 0.0158113883$ (I have used a calculator).

Let's try to apply our test to the right answer divided by two.
#+begin_src emacs lisp
  (good-enough? (/ 0.0158113883 2) 0.00025)
#+end_src
The test returns true; that is, it's telling us that half of the right
answer is good enough. I take that as a failure.

When we are dealing with very small numbers, then the $0.001$ used in
our test is too big for our purposes.

This is a pretty big number: $7894561230.0123456789$. The square root
of this number is $\sqrt{7894561230.0123456789} = 88851.3434339$ (I
have used a calculator).

Let's see whether are test consider the right answer as good
enough...

#+begin_src emacs-lisp
  (good-enough? 88851.3434339 7894561230.0)
#+end_src

This evaluate to ~nil~...  The problem seems to lie in the application
of (the procedure named by) ~square~, which gives a rather imprecise
result.

This is the body of ~good-enough?~:
#+begin_src emacs-lisp
  (< (abs (- (square 88851.3434339) 7894561230.0)) 0.001)
#+end_src
It evaluates to ~nil~, because the difference between the square of
the guess and the radicant is greater than 0.001. However, the
/actual/ square of the radicant does not differ from the radicant of a
value greater than 0.001.


Here is my version of an improved version of ~good-enough?~ following
the authors' suggestion:

#+begin_src emacs-lisp
  (defun good-enough-improved? (new-guess old-guess)
    (< (abs (- (abs old-guess) (abs new-guess))) (/ old-guess 10000000.0)))

  (defun sqrt-iter2 (new-guess old-guess x)
    (if (good-enough-improved? new-guess old-guess)
        new-guess
      (sqrt-iter2 (improve new-guess x) new-guess x)))

  (defun sqrt2 (x)
    (sqrt-iter2 1.0 x x))
#+end_src

My version seems to work much better for small numbers:
#+begin_src emacs-lisp
  (sqrt 0.00025) ;; => 0.033869844451165365
  ;;    bad!
  (sqrt2 0.00025) ;; => 0.015811388300841896
  ;;    As good as the built-in emacs lisp sqrt function!
#+end_src

But there doesn't seem to be no difference with big numbers:
#+begin_src emacs-lisp
  (sqrt 7894561230.0)  ;; 88851.34343385023
  (sqrt2 7894561230.0) ;; 88851.34343385023
#+end_src
This is so, I think, because, even if ~good-enough?~ returns ~nil~
when it shouldn't, ~improve~ is called until we get something that
differs from the radicant for less than 0.001... is this correct?

*** Exercise 1.8
Exercise:

#+begin_quote
Newton’s method for cube roots is based on the fact that if $y$ is an
approximation to the cube root of $x$, then a better approximation is
given by the value $\frac{x/y^2 + 2y}{3}$. Use this formula to
implement a cube-root procedure analogous to the square-root
procedure. (In 1.3.4 we will see how to implement Newton’s method in
general as an abstraction of these square-root and cube-root
procedures.)
#+end_quote

Answer:

#+begin_src emacs-lisp
  (defun cuberoot (x)
    (cuberoot-iter2 1.0 x x))

  (defun cuberoot-iter (new-guess old-guess x)
    (if (good-enough-improved? new-guess old-guess)
        new-guess
      (cuberoot-iter2 (improve-cr new-guess x) new-guess x)))

  (defun improve-cr (guess x)
    (/ (+ (/ x (square guess))
          (* 2 y))
       3))


#+end_src
** 1.2 Procedures and the Processes They Generate
- Analogy with chess. Mastering the rules doesn't make you a master
  player. So far, we have only learnt the rules.
- To become expert programmers, we must learn to visualize the
  processes generated by various procedures. (Analogy with
  photography.)
- ``A procedure is a pattern for the /local evolution/ of a
  computational process''.
- Making statements about the /global/ behavior of a process (whose
  local evolution has been specified by a procedure) is a difficult
  task.
- We can try to describe some typical patterns of process evolution.
- In this section we will:
  - examine some common processes' ``shapes'';
  - investigate the rate at which these processes consume
    computational resources (space and time).
*** 1.2.1 Linear Recursion and Iteration
$n! = n \times (n - 1) \times (n - 1) \dots 3 \times 2 \times 1$

#+begin_export latex
$n! = n \times (n - 1) \times (n - 1) \dots 3 \times 2 \times 1$
#+end_export

One way to compute factorials:
#+begin_src scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+end_src

Using the substitution model we can ``watch this procedure in
action'' (computing 6!):
#+begin_src scheme
  (factorial 6)
  (* 6 (factorial 5))
  (* 6 (* 5 (factorial 4)))
  (* 6 (* 5 (* 4 (factorial 3))))
  (* 6 (* 5 (* 4 (* 3 (factorial 2)))))
  (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
  (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
  (* 6 (* 5 (* 4 (* 3 2))))
  (* 6 (* 5 (* 4 6)))
  (* 6 (* 5 24))
  (* 6 120)
  720
#+end_src

Here is another way to compute the factorial:
#+begin_src scheme
  (define (factorial n)
    (fact-iter 1 1 n))

  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+end_src

Let's ``visualize the process'' (of computing 6!):
#+begin_src scheme
  (factorial 6)
  (fact-iter 1 1 6)
  (fact-iter 1 1 6)
  (fact-iter 6 2 6)
  (fact-iter 12 3 6)
  (fact-iter 36 4 6)
  (fact-iter 144 5 6)
  (fact-iter 720 6 6)
  720
#+end_src

- Both processes:
  - compute the same mathematical function on the same domain;
  - require a number of steps proportional to ~n~ to compute ~n!~.

- However, we can notice a difference in ``shape'' between the ways
  the two processes evolve.
  - The first process is /recursive process/. Its evolutions shows
    /expansion/ and /contraction/. Expansion corresponds to /deferred
    operations/. Contraction corresponds to /performed
    operations/. The latter are to be kept track of. The amount of
    information we need to keep track of is proportionial to ~n~ ---
    it grows linearly with ~n~. This recursive process is therefore
    said to be /linear/.
  - The second process is an /iterative process/. The state of such a
    process can summarized in terms of a fixed number of state
    variables and the fixed rules to update those variables when
    moving from one state to the next one, and, optionally, the
    condition under which the process should terminate. We can see
    that the number of steps grows linearly with ~n~. This iterative
    process is therefore said to be /linear/.

- Another way to see the difference between the two processes: ``In
  the iterative case, the program variables provide a complete
  description of the state of the process at any point''. In the
  recursive case, some ``hidden information'' is maintained by the
  interpreter.

- Let's not confuse the notion of a recursive /process/ with that of a
  recursive /procedure/.

- Tail recursion.

*** Exercise 1.9
#+begin_quote
Each of the following two procedures defines a method for adding two
positive integers in terms of the procedures inc, which increments its
argument by 1, and dec, which decrements its argument by 1.

#+begin_src scheme
  (define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))

  (define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
#+end_src

Using the substitution model, illustrate the process generated by each
procedure in evaluating (+ 4 5). Are these processes iterative or
recursive?
#+end_quote

#+begin_src scheme
  (+ 4 5)
  (inc (+ 3 5))
  (inc (inc (+ 2 5)))
  (inc (inc (inc (+ 1 5))))
  (inc (inc (inc (inc (+ 0 5)))))
  (inc (inc (inc (inc 5))))
  (inc (inc (inc 6)))
  (inc (inc 7))
  (inc 8)
  9
#+end_src
Judging by its shape, it looks like we are dealing with a recursive
process!

#+begin_src scheme
  (+ 4 5)
  (+ 3 6)
  (+ 2 7)
  (+ 1 8)
  (+ 0 9)
  9
#+end_src
Judging by its shape, it looks like we are dealing with an iterative
process!

*** Exercise 1.10
Exercise:
#+begin_quote
The following procedure computes a mathematical function called Ackermann’s function.

#+begin_src scheme
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+end_src
What are the values of the following expressions?

#+begin_src scheme
  (A 1 10)
  (A 2 4)
  (A 3 3)
#+end_src

Consider the following procedures, where A is the procedure defined above:
#+begin_src scheme
  (define (f n) (A 0 n))
  (define (g n) (A 1 n))
  (define (h n) (A 2 n))
  (define (k n) (* 5 n n))
#+end_src
Give concise mathematical definitions for the functions computed by
the procedures $f$, $g$, and $h$ for positive integer values of
$n$. For example, $(k n)$ computes $5n^2$.
#+end_quote

Answer:
#+begin_src scheme
  ;; let's see the evolution of (A 1 10):

  (A 1 10)

  (A 0 (A 1 9))

  (A 0 (A 0 (A 1 8)))

  (A 0 (A 0 (A 0 (A 1 7))))

  (A 0 (A 0 (A 0 (A 0 (A 1 6)))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 32)))))

  (A 0 (A 0 (A 0 (A 0 64))))

  (A 0 (A 0 (A 0 128)))

  (A 0 (A 0 256))

  (A 0 512)

  1024

  ;; We are looking at a recursive process. The answer is 1024.

#+end_src

#+begin_src scheme
  ;; Let's do the same with (A 2 4).

  (A 2 4)

  (A 1 (A 2 3))

  (A 1 (A 1 (A 2 2)))

  (A 1 (A 1 (A 1 (A 2 1))))

  (A 1 (A 1 (A 1 2)))

  (A 1 (A 1 (A 0 (A 1 1))))

  (A 1 (A 1 (A 0 2)))

  (A 1 (A 1 4))

  (A 1 (A 0 (A 1 3)))

  (A 1 (A 0 (A 0 (A 1 2))))

  (A 1 (A 0 (A 0 (A 0 (A 1 1)))))

  (A 1 (A 0 (A 0 (A 0 2))))

  (A 1 (A 0 (A 0 4)))

  (A 1 (A 0 8))

  (A 1 16)

  (A 0 (A 1 15))

  (A 0 (A 0 (A 1 14)))

  (A 0 (A 0 (A 0 (A 1 13))))

  (A 0 (A 0 (A 0 (A 0 (A 1 12)))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))

  (A 0 (A 0 (A 0 (A 0 4096))))

  (A 0 (A 0 (A 0 8192)))

  (A 0 (A 0 16384))

  (A 0 32768)

  65536

  ;; interesting shape... the answer is 65536
#+end_src

#+begin_src scheme
  ;; Let's see now the evolution of (A 3 3):

  (A 3 3)

  (A 2 (A 3 2))

  (A 2 (A 2 (A 3 1)))

  (A 2 (A 2 2))

  (A 2 (A 1 (A 2 1)))

  (A 2 (A 1 2))

  (A 2 (A 0 (A 1 1)))

  (A 2 (A 0 2))

  (A 2 4) ;; We already know this one!

  65536
#+end_src

~(f 1)~ is 2:
#+begin_src scheme
  (f 1)

  (A 0 1)

  2
#+end_src

~(f 2)~ is 4:
#+begin_src scheme
  (f 2)

  (A 0 2)

  4
#+end_src

~(f 3)~ is 6:
#+begin_src scheme
  (f 3)

  (A 0 3)

  (A 6)
#+end_src

I conclude that ~(f n)~ computes $n \times 2$.

~(g 1)~ is 2:
#+begin_src scheme
  (g 1)

  (A 1 1)

  2
#+end_src

~(g 2)~ is 4:
#+begin_src scheme
  (g 2)

  (A 1 2)

  (A 0 (A 1 1))

  (A 0 2)

  4
#+end_src

~(g 3)~ is 8:
#+begin_src scheme
  (g 3)

  (A 1 3)

  (A 0 (A 1 2)) ;; we already know that (A 1 2) is 4

  (A 0 4)

  8
#+end_src

~(g 4)~ is 16:
#+begin_src scheme
  (g 4)

  (A 1 4)

  (A 0 (A 1 3)) ;; we already know that (A 1 3) is 8

  (A 0 8)

  16
#+end_src

Those are the powers of two. I conclude that ~(g n)~ computes $2^n$.


~(h 1)~ is 2:
#+begin_src scheme
  (h 1)

  (A 2 1)

  2
#+end_src

~(h 2)~ is 4:
#+begin_src scheme
  (h 2)

  (A 2 2)

  (A 1 (A 2 1))

  (A 1 2)

  (A 0 (A 1 1))

  (A 0 2)

  4
#+end_src

~(h 3)~ is 16:
#+begin_src scheme
  (h 3)

  (A 2 3)

  (A 1 (A 2 2))

  (A 1 (A 1 (A 2 1)))

  (A 1 (A 1 2))

  (A 1 (A 0 (A 1 1)))

  (A 1 (A 0 2))

  (A 1 4) ;; we already know that (A 1 4) is 16

  16
#+end_src

~(h 4)~ is 65536.
#+begin_src scheme
  (h 4)

  (A 2 4) ;; we know this one already...

  65536
#+end_src

~(h 5)~ is
#+begin_src scheme
  (h 5)

  (A 2 5)

  (A 1 (A 2 4)) ;; (A 2 4) is 65536

  (A 1 65536)

  (A 0 (A 1 65535))

  (A 0 (A 0 (A 1 65635))) ;; oh oh... this would take a while...
#+end_src

~(h 4)~ is $65536$, which is $2^{16}$. ~(h 3)~ is $16$, which is
$2^4$. ~(h 2)~ is $4$, which is $2^2$. My answer, then, is that ~(h
n)~ computes $n^{(h (1- n)))}$ where `(h (1- n))` is the application
of ~h~ to ~n~ minus 1.

*** 1.2.2 Tree Recursion
#+begin_src scheme
  (define (count-change amount)
    (cc amount 5))

  (define (cc amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins)))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))
#+end_src

- I wonder: what is an example of non-linear iteration?

*** Exercises 1.11
Exercise:

#+begin_quote
A function f is defined by the rule that $f(n) = n$ if $n <3 $ and
$f(n) = f(n−1) + 2f(n−2) + 3f(n−3)$ if $n \geq 3$. Write a procedure
that computes $f$ by means of a recursive process. Write a procedure
that computes $f$ by means of an iterative process.
#+end_quote

Answer:

Writing a procedure that computes ~f~ by means of a recursive process
is quite straightforward.
#+begin_src emacs-lisp
  (defun f (n)
    (cond
     ((< n 3) n)
     (t (+ (f (- n 1))
           (* 2 (f (- n 2)))
           (* 3 (f (- n 3)))))))

  (f 0)  ;; 0
  (f 1)  ;; 1
  (f 2)  ;; 2
  (f 3)  ;; 4
  (f 4)  ;; 11
  (f 5)  ;; 25
#+end_src

Writing a (recursive) procedure that computes ~f~ by means of an
iterative process is less straightforward.

My thought process: up to 2 we know the answer; the answer is the very
same input. For a number ~n~ greater than 2, we are able to compute
the answer if we know the result for the inputs ~n - 1~, ~n - 2~, and
~n - 3~. In the case of of number 3 --- the first number greater than
2 --- we do know the answer for the inputs 3-1, 3-2, and 3-3. They
are, respectively, 2, 1, and 0. Given that we know that we can compute
the value of the function given input 3: ....  But now we have the
enough knowledge to compute the value of the function given the
input 4. And once we know that... etc.

So we can use a counter that starts from 0 and iterate until we have
done the right number of ``loops'', keeping track of the three
relevant values that allows us to compute the value of the process at
that time.

#+begin_src emacs-lisp
  (defun f2 (n)
    (f-iter 0 n 0 1 2))

  (defun f-iter (counter max-count A B C)
    (if (< counter max-count) ;; keep iterating
        (if (< counter 3)
            (f-iter (1+ counter) max-count 0 1 2)
          (f-iter (1+ counter) max-count B C (+ (* 3 A)
                                                (* 2 B)
                                                C)))
      (if (< counter 3)
          counter
        (+ (* 3 A)
           (* 2 B)
           C))))

  (f2 0) ;; 0
  (f2 1) ;; 1
  (f2 2) ;; 2
  (f2 3) ;; 4
  (f2 4) ;; 11
  (f2 5) ;; 25
#+end_src

*** Exercise 1.12
Exercise:
#+begin_quote
....
#+end_quote

Answer:

Here is an iterative solution in js I could quickly come up with:

#+begin_src js
  function tartaglia(n) {
    let previousLine = [1, 1,];
    for (let i = 0; i < n; i++) {
      if (i == 0) {
        console.log( [1] )
      } else if (i == 1) {
        console.log( [1, 1] );
      } else {
        previousLine = line(previousLine);
        console.log(previousLine);
      }
    }
  }

  //Compute line given previous one
  function line(arr) {
    let result = [1, ];
    for (let i = 0; i < arr.length-1; i++) {
      result.push(arr[i] + arr[i+1]);
    }
    result.push(1);
    return result;
  }

  tartaglia(5);
  // =>
  // [ 1 ]
  // [ 1, 1 ]
  // [ 1, 2, 1 ]
  // [ 1, 3, 3, 1 ]
  // [ 1, 4, 6, 4, 1 ]
#+end_src

So... after too much thinking, while brushing my teeth and almost in
bed, I came up with a solution.

You can think of the triangle just as a bunch of lines/rows, each of
which is one element more than the previous one.

#+begin_src
a
b, c
d, e, f
g, h, i, j
...
#+end_src

What helped me to find a solution was using a row[col] notation.
#+begin_src
0[0]
1[0], 1[1]
2[0], 2[1], 2[2]
3[0], 3[1], 3[2], 3[3]
4[0], 4[1], 4[2], 4[3], 4[4]
#+end_src
We can immediately notice two things:
- first, col=0 means we are dealing with the first element of a
  row. But the first element of a row is always a 1.
- second, when row=col we are dealing with the last element of a
  row. But the last element of a row is always a 1.

Finally, we need a way to find the value of those elements where
neither row≠col nor col=0. Saying that an element equals the sum of
the two numbers ``above'' it is equivalent to say that an element with
inidex i at row r is equal to the sum of two elements at row r-1, more
specifically to the sum of those two elements the first one of which
has index i-1 and the second one of which has index i.

We have enough rules.
#+begin_src emacs-lisp
  ;;(tartaglia row col)
  ;;
  ;;col=0   ==> 1
  ;;col=row ==> 1
  ;;else    ==> (+ (tartaglia (1- row)(1- col))
  ;;               (tartaglia (1- row) col))
#+end_src

We can write our procedure!
#+begin_src emacs-lisp
  (defun tartaglia (r c)
    (cond
     ((= c 0) 1)
     ((= r c) 1)
     (t (+ (tartaglia (1- r)(1- c))
           (tartaglia (1- r) c)))))

  (tartaglia 0 0)
  ;; => 1
  (tartaglia 1 0) (tartaglia 1 1)
  ;; => 1, 1
  (tartaglia 2 0) (tartaglia 2 1) (tartaglia 2 2)
  ;; => 1, 2, 1
  (tartaglia 3 0) (tartaglia 3 1) (tartaglia 3 2) (tartaglia 3 3)
  ;; => 1, 3, 3, 1
  (tartaglia 4 0) (tartaglia 4 1) (tartaglia 4 2) (tartaglia 4 3) (tartaglia 4 4)
  ;; 1, 4, 6, 4, 1
#+end_src

It works!
*** 1.2.3 Orders of Growth
*** Exercise 1.14
Exercise:
#+begin_quote
Draw the tree illustrating the process generated by the count-change
procedure of 1.2.2 in making change for 11 cents. What are the orders
of growth of the space and number of steps used by this process as the
amount to be changed increases?
#+end_quote

Answer:
Here how the process looks like when using the substitution model:
#+begin_src emacs-lisp
  (defun count-change (amount)
    (cc amount 5))

  (defun cc (amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0)
               (= kinds-of-coins 0))
           0)
          (t
           (+ (cc amount (- kinds-of-coins 1))
              (cc (- amount (first-denomination
                             kinds-of-coins))
                  kinds-of-coins)))))

  (defun first-denomination (kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (count-change 11)

  (count-change 11)

  (cc 11 5)

  (+ (cc 11 (- 5 1))
     (cc (- 11 (first-denomination
                5))
         5))

  (+ (cc 11 4)
     (cc -39 5))

  (+ (cc 11 4)
     0)

  (+ (+ (cc 11 (- 4 1))
        (cc (- 11 (first-denomination
                   4))
            4))
     0)

  (+ (+ (cc 11 3)
        (cc -14 4))
     0)

  (+ (+ (cc 11 3)
        0)
     0)

  (+ (+ (+ (cc 11 (- 3 1))
           (cc (- 11 (first-denomination
                      3))
               3))
        0)
     0)

  (+ (+ (+ (cc 11 2)
           (cc 1 3))
        0)
     0)

  (+ (+ (+ (+ (cc 11 (- 2 1))
              (cc (- 11 (first-denomination
                         2))
                  2))
           (+ (cc 1 (- 3 1))
              (cc (- 1 (first-denomination
                        3))
                  3)))
        0)
     0)

  (+ (+ (+ (+ (cc 11 1)
              (cc 6 2))
           (+ (cc 1 2)
              (cc -9 3)))
        0)
     0)

  (+ (+ (+ (+ (cc 11 1)
              (cc 6 2))
           (+ (cc 1 2)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ (cc 11 (- 1 1))
                 (cc (- 11 (first-denomination
                            1))
                     1))
              (+ (cc 6 (- 2 1))
                 (cc (- 6 (first-denomination
                           2))
                     2)))
           (+ (+ (cc 1 (- 2 1))
                 (cc (- 1 (first-denomination
                           2))
                     2))
              0))
        0)
     0)

  (+ (+ (+ (+ (+ (cc 11 0)
                 (cc 10 1))
              (+ (cc 6 1)
                 (cc 1 2)))
           (+ (+ (cc 1 1)
                 (cc -4 2))
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (cc 10 1))
              (+ (cc 6 1)
                 (cc 1 2)))
           (+ (+ (cc 1 1)
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ (cc 10 (- 1 1))
                    (cc (- 10 (first-denomination
                               1))
                        1)))
              (+ (+ (cc 6 (- 1 1))
                    (cc (- 6 (first-denomination
                              1))
                        1))
                 (+ (cc 1 (- 2 1))
                    (cc (- 1 (first-denomination
                              2))
                        2))))
           (+ (+ (+ (cc 1 (- 1 1))
                    (cc (- 1 (first-denomination
                              1))
                        1))
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ (cc 10 0)
                    (cc 9 1)))
              (+ (+ (cc 6 0)
                    (cc 5 1))
                 (+ (cc 1 1)
                    (cc -4 2))))
           (+ (+ (+ (cc 1 0)
                    (cc 0 1))
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (cc 9 1)))
              (+ (+ 0
                    (cc 5 1))
                 (+ (cc 1 1)
                    0)))
           (+ (+ (+ 0
                    1)
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (cc 9 1)))
              (+ (+ 0
                    (cc 5 1))
                 (+ (cc 1 1)
                    0)))
           (+ (+ 1
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ (cc 9 (- 1 1))
                       (cc (- 9 (first-denomination
                                 1))
                           1))))
              (+ (+ 0
                    (+ (cc 5 (- 1 1))
                       (cc (- 5 (first-denomination
                                 1))
                           1)))
                 (+ (+ (cc 1 (- 1 1))
                       (cc (- 1 (first-denomination
                                 1))
                           1))
                    0)))
           (+ (+ 1
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ (cc 9 0)
                       (cc 8 1))))
              (+ (+ 0
                    (+ (cc 5 0)
                       (cc 4 1)))
                 (+ (+ (cc 1 0)
                       (cc 0 1))
                    0)))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (cc 8 1))))
              (+ (+ 0
                    (+ 0
                       (cc 4 1)))
                 (+ (+ 0 1)
                    0)))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (cc 8 1))))
              (+ (+ 0
                    (+ 0
                       (cc 4 1)))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ (cc 8 (- 1 1))
                          (cc (- 8 (first-denomination
                                    1))
                              1)))))
              (+ (+ 0
                    (+ 0
                       (+ (cc 4 (- 1 1))
                          (cc (- 4 (first-denomination
                                    1))
                              1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ (cc 8 (- 1 1))
                          (cc (- 8 1) 1)))))
              (+ (+ 0
                    (+ 0
                       (+ (cc 4 (- 1 1))
                          (cc (- 4 1) 1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ (cc 8 0)
                          (cc 7 1)))))
              (+ (+ 0
                    (+ 0
                       (+ (cc 4 0)
                          (cc 3 1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (cc 7 1)))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (cc 3 1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (+ (cc 7 (- 1 1))
                               (cc (- 7 (first-denomination
                                         1))
                                   1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (+ (cc 3 (- 1 1))
                               (cc (- 3 (first-denomination
                                         1))
                                   1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (+ (cc 7 (- 1 1))
                               (cc (- 7 1)
                                   1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (+ (cc 3 (- 1 1))
                               (cc (- 3 1)
                                   1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (+ (cc 7 0)
                               (cc 6 1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (+ (cc 3 0)
                               (cc 2 1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (cc 6 1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (cc 2 1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 6 (- 1 1))
                                  (cc (- 6 (first-denomination
                                            1))
                                      1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 2 (- 1 1))
                                  (cc (- 2 (first-denomination
                                            1))
                                      1))))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 6 (- 1 1))
                                  (cc (- 6 1)
                                      1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 2 (- 1 1))
                                  (cc (- 2 1)
                                      1))))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 6 0)
                                  (cc 5 1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 2 0)
                                  (cc 1 1))))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (cc 5 1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (cc 1 1))))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 5 (- 1 1))
                                   (cc (- 5 (first-denomination
                                             1))
                                       1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 1 (- 1 1))
                                   (cc (- 1 (first-denomination
                                             1))
                                       1)))))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 5 (- 1 1))
                                   (cc (- 5 1)
                                       1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 1 (- 1 1))
                                   (cc (- 1 1)
                                       1)))))))
                 1))
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 5 0)
                                   (cc 4 1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 1 0)
                                   (cc 0 1)))))))
                 1))
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (cc 4 1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0 1))))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ (cc 4 (- 1 1))
                                      (cc (- 4 (first-denomination
                                                1))
                                          1)))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0 1)))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ (cc 4 (- 1 1))
                                      (cc (- 4 1)
                                          1)))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 1))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ (cc 4 0)
                                      (cc 3 1)))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 1)))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (cc 3 1)))))))))
              (+ (+ 0
                    (+ 0 1))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ (cc 3 (- 1 1))
                                         (cc (- 3 (first-denomination
                                                   1))
                                             1))))))))))
              (+ (+ 0 1)
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ (cc 3 (- 1 1))
                                         (cc (- 3 1)
                                             1))))))))))
              (+ 1 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ (cc 3 0)
                                         (cc (- 3 1)
                                             1))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (cc 2 1))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ (cc 2 (- 1 1))
                                            (cc (- 2 (first-denomination
                                                      1))
                                                1)))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ (cc 2 (- 1 1))
                                            (cc (- 2 1)
                                                1)))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ (cc 2 0)
                                            (cc 1 1)))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ (cc 1 (- 1 1))
                                               (cc (- 1 (first-denomination
                                                         1))
                                                   1))))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ (cc 1 (- 1 1))
                                               (cc (- 1 1)
                                                   1))))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ (cc 1 0)
                                               (cc 0 1))))))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ 0 1)))))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0 1))))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0 1)))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0 1))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0 1)))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0 1))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 1)))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 1))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0 1)))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0 1))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0 1)
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ 1 2)
           1)
        0)
     0)


  (+ (+ (+ 3 1)
        0)
     0)


  (+ (+ 4 0)
     0)


  (+ 4 0)

  4
#+end_src

Analogously to what has been done at page 38 with ~fib~, we can
represent tree generated by ~count-change~ in the following way:
#+begin_src
                                                            (count-change 11)
                                                               (cc 11 5)
                                                               /       \
                                                       (cc 11 4)      (cc - 39 5)
                                                       /      \             \
                                                  (cc 11 3)  (cc -14 4)      0
                                                   /      \         \
                                              (cc 11 2)  (cc 1 3)    0
                                              /     \      /     \
                                     (cc 11 1) (cc 6 2) (cc 1 2) (cc -9 3)
                                     ___|      /\____     |_____          \
                                 ___/   |     |      |    |____ \_______   \_____
                                |       |     |       \        |        |        |
                        (cc 11 0) (cc 10 1) (cc 6 1) (cc 1 2) (cc 1 1) (cc -4 2) 0
                        ___/   ____/ |         /\        |\         |_________    \__________
                  _____/   ___|     /         /  \       | \_____   \_______  |______        |
                 |        |        /         /   |       |       |          |        |       |
                 0 (cc 10 0) (cc 9 1) (cc 6 0) (cc 5 1) (cc 1 1) (cc -4 2) (cc 1 0) (cc 0 1) 0
                      /       /\        /      / \         |\____     \       |      |
                   __/     __/  \      /      /   \        |     \___  \_____ |      |
                  |       /      |    |      /     \       |         |      | |      |
                  0 (cc 9 0) (cc 8 1) 0 (cc 5 0) (cc 4 1) (cc 1 0) (cc 0 1) 0 0      1
                      |          /\          |        |\__       \   |
                      |         /  \         |        |   \       \  |
                      0  (cc 8 0)  (cc 7 1)  0  (cc 4 0) (cc 3 1) 0  1
                          |          /\          |          /\
                          |         /  \         |         /  \
                          0  (cc 7 0)  (cc 6 1)  0  (cc 3 0)  (cc 2 1)
                               |          /\          |          /\
                               |         /  \         |         /  \
                               0  (cc 6 0)  (cc 5 1)  0  (cc 2 0)  (cc 1 1)
                                   /        /\           /         /\
                                  /        /  \         |         /  \
                                 0  (cc 5 0)  (cc 4 1)  0  (cc 1 0) (cc 0 1)
                                      |          /\           |        |
                                      |         /  \          |        |
                                      0  (cc 4 0)  (cc 3 1)   0        1
                                            |           /\
                                            |          /  \
                                            0   (cc 3 0)  (cc 2 1)
                                                   |           /\
                                                   |          /  \
                                                   0   (cc 2 0)  (cc 1 1)
                                                          |           /\
                                                          |          /  \
                                                          0   (cc 1 0)  (cc 0 1)
                                                                  |        |
                                                                  0        1
#+end_src
This looks like a tree recursive processe like that of ~fib~. And
#+begin_quote
In general, the number of steps required by a tree-recursive process
will be proportional to the number of nodes in the tree, while the
space required will be proportional to the maximum depth of the tree
(p.39).
#+end_quote

So the order of growth in time of ~count-change~ is $\Theta(n^2)$ and
the order of growth in space is $\Theta(n)$. Is it? (I had a look at
solutions online and I see that the situation might be more complex
than I thought.)

*** Exercise 1.15
Exercise:
#+begin_quote
The sine of an angle (specified in radians) can be computed by making
use of the approximation $\sin x \approx x$if $x$ is sufficiently
small, and the trigonometric identity

$\sin x = 3 \sin \frac{x}{3} - 4 \sin^3 \frac{x}{3}$

to reduce the size of the argument of $\sin$. (For purposes of this
exercise an angle is considered ``sufficiently small'' if its
magnitude is not greater than 0.1 radians.) These ideas are
incorporated in the following procedures:

#+begin_src scheme
  (define (cube x) (* x x x))
  (define (p x) (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))
#+end_src

1. How many times is the procedure p applied when ~(sine 12.15)~ is
   evaluated?
2. What is the order of growth in space and number of steps (as a
   function of ~a~) used by the process generated by the ~sine~
   procedure when ~(sine a)~ is evaluated?
#+end_quote

Answer:
#+begin_src emacs-lisp
  (defun cube (x) (* x x x))
  (defun p (x) (- (* 3 x) (* 4 (cube x))))
  (defun sine (angle)
    (if (not (> (abs angle) 0.1))
        angle
      (p (sine (/ angle 3.0)))))
#+end_src

#+begin_src emacs-lisp
  (defun cube (x) (* x x x))
  (defun p (x) (- (* 3 x) (* 4 (cube x))))
  (defun sine (angle)
    (if (not (> (abs angle) 0.1))
        angle
      (p (sine (/ angle 3.0)))))


  (sine 12.15) ;; -0.39980345741334
  (p (sine (/ 12.15 3.0)))
  (p (sine 4.05))
  (p (p (sine (/ 4.05 3.0))))
  (p (p (sine 1.3499999999999999)))
  (p (p (p (sine (/ 1.3499999999999999 3.0)))))
  (p (p (p (sine 0.44999999999999996))))
  (p (p (p (p (sine (/ 0.44999999999999996 3.0))))))
  (p (p (p (p (sine 0.15)))))
  (p (p (p (p (p (sine (/ 0.15 3.0)))))))
  (p (p (p (p (p (sine 0.049999999999999996))))))
  (p (p (p (p (p (sine 0.049999999999999996))))))
  (p (p (p (p (p 0.049999999999999996)))))
  (p (p (p (p (- (* 3 0.049999999999999996) (* 4 (cube 0.049999999999999996)))))))
  (p (p (p (p 0.1495))))
  (p (p (p 0.4351345505)))
  (p (p 0.9758465331678772))
  (p -0.7895631144708228)
  (- -2.3686893434124685 -1.9688858859991285)
  -0.39980345741334
#+end_src
1. Procedure ~p~ is applied five times.

2. I tentatively thought that the order of growth in space and time
   was O(n).

   However I've looked arout at other people's solutions and that is
   not right. The order of growth is better than linear; it's
   logarithmic, O(log(n)); more specifically O(log3(n)). I
   definitively need to revive my math skills, assuming they still
   exist somewhere.

   This was the most intuitive explanation I've found of why that is
   so: ``the amount of times ~p~ is evaluated is incremented by one
   for every tripling of ~a~. [...] As for the order of growth
   regarding space, it should be the same as for the number of steps,
   because for each additional step, there is exactly one more
   function call that the system must keep track of''
   (https://www.timwoerner.de/posts/sicp/exercises/1/15/)
*** 1.2.4 Exponentiation
$b^n = b \times b^(n-1)$, and $b^0 = 1$.  Translating this into a
procedure:
#+begin_src emacs-lisp
  (defun expt (b n)
    (if (= n 0)
        1
      (* b (expt b (- n 1)))))
#+end_src
This requires  ϴ(n) steps and  ϴ(n) space.

We have have already seen such a kind of process (linear recursion)
with factorial. JUst as with factorial, we can write a procedurs that
evolves a linear iterative process:

#+begin_src emacs-lisp
  (defun expt-iter (b counter product)
    (if (= counter 0)
        product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
#+end_src
This process requires ϴ(n) steps and ϴ(1) space.

We can be faster.
#+begin_src emacs-lisp
  (defun fast-expt (b n)
    (cond ((= n 0)
           1)
          ((even? n)
           (square (fast-expt b (/ n 2))))
          (t
           (* b (fast-expt b (- n 1))))))

  (defun (even? n)
      (= (remainder n 2) 0))
#+end_src
~fast-expt~ evolves a process that grows /logarithmically/ with n in
both space and time.
*** Exercise 1.16
Exercise:
#+begin_quote
Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does ~fast-expt~. (Hint: Using the observation that $(b^{b/2})^2 =
(b^2)^{n/2}$, keep, along with the exponent n and the base b, an
additional state variable a, and define the state transformation in
such a way that the product abn is unchanged from state to state. At
the beginning of the process a is taken to be 1, and the answer is
given by the value of a at the end of the process. In general, the
technique of defining an invariant quantity that remains unchanged
from state to state is a powerful way to think about the design of
iterative algorithms.)
#+end_quote

Answer:
#+begin_src emacs-lisp
  (defun fast-expt-i (b n)
    (fast-expt-iter b n 1))

  (defun fast-expt-iter (b n a)
    (cond ((= n 0) a)
          ((even n)
           (fast-expt-iter (square b) (/ n 2) a))
          (t
           (fast-expt-iter b (- n 1) (* b a)))))
#+end_src

I've asked ChatGPT about whether it thought that this solution was
correct. Here is the answer:
#+begin_quote
Yes, the provided implementation of the fast-expt-i function and the
fast-expt-iter function appears to correctly compute the value of the
exponentiation with base b and exponent n.

The fast-expt-i function is a wrapper function that calls the
fast-expt-iter function with the initial value of a set to 1. The
fast-expt-iter function is a recursive function that implements the
exponentiation algorithm using a technique called "iterative
deepening," which allows for more efficient computation of
exponentiation by repeatedly squaring the base and halving the
exponent until the exponent becomes 0.

The cond statement in the fast-expt-iter function handles the base
case where the exponent is 0, as well as the cases where the exponent
is even or odd. In the case where the exponent is 0, the function
returns the value of a, which is the result of the exponentiation. In
the case where the exponent is even, the function calls itself with
the square of the base and half the exponent, and in the case where
the exponent is odd, the function calls itself with the base and the
exponent decremented by 1.

Overall, the provided implementation appears to correctly compute the
value of the exponentiation with base b and exponent n.
#+end_quote

I've also asked about space complexity:
#+begin_quote
The order of growth in space of the fast-expt-i function is O(n),
where n is the value of the exponent. This is because the function
uses recursive calls to compute the exponentiation, and each recursive
call requires additional space on the call stack to store the local
variables and intermediate results.

In the case of the fast-expt-i function, the space required for each
recursive call is constant, as it only stores the values of the base
b, exponent n, and accumulator a variables. Therefore, the total space
required by the function is proportional to the number of recursive
calls, which is equal to the value of the exponent.

For example, if the exponent has a value of n, the function will
require O(n) space to compute the result, as it will make n recursive
calls. This is known as linear space complexity.

It is important to note that the space complexity of the fast-expt-i
function can be improved by using a technique called "tail call
optimization," which allows the compiler to reuse the space on the
call stack for the recursive calls, rather than allocating additional
space for each call. This can reduce the space complexity of the
function to O(1), as only a constant amount of space is required to
store the local variables and intermediate results. However, this
optimization is not performed by default in most Lisp implementations,
and may require explicit support from the compiler or runtime
environment.
#+end_quote

*** Exercise 1.17
#+begin_quote
The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way,
one can perform integer multiplication by means of repeated
addition. The following multiplication procedure (in which it is
assumed that our language can only add, not multiply) is analogous to
the expt procedure:
#+begin_src scheme
  (define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+end_src
This algorithm takes a number of steps that is linear in b. Now
suppose we include, together with addition, operations double, which
doubles an integer, and halve, which divides an (even) integer
by 2. Using these, design a multiplication procedure analogous to
fast-expt that uses a logarithmic number of steps.
#+end_quote

Answer:
#+begin_src emacs-lisp
  (defun double (a)
    (* a 2))

  (defun halve (a)
    (/ a 2))

  (defun fast-* (a b)
    (cond ((= b 1) a)
          ((even b) (double (fast-* a (halve b))))
          (t (+ a (fast-* a (- b 1))))))
#+end_src

*** Exercise 1.18
Exercise:
#+begin_quote
Using the results of Exercise 1.16 and Exercise 1.17, devise a
procedure that generates an iterative process for multiplying two
integers in terms of adding, doubling, and halving and uses a
logarithmic number of steps (fn: This algorithm, which is sometimes
known as the “Russian peasant method” of multiplication, is
ancient. Examples of its use are found in the Rhind Papyrus, one of
the two oldest mathematical documents in existence, written about 1700
B.C. (and copied from an even older document) by an Egyptian scribe
named A’h-mose.)
#+end_quote

Answer
#+begin_src emacs-lisp
  (defun fast-*-i (a b)
    (fast-*-iter a b 0))

  (defun fast-*-iter (a b c)
    (cond ((= c 0) 0)
          ((even b) (fast-*-iter (double a) (halve b) c))
          (t (fast-*-iter a (- b 1) (+ a c))
#+end_src

*** Exercise 1.19
#+begin_quote
There is a clever algorithm for computing the Fibonacci numbers in a
logarithmic number of steps. Recall the transformation of the state
variables a and b in the fib-iter process of 1.2.2: $a \leftarrow a +
b$ and $b \leftarrow a$. Call this transformation $T$, starting with
the pair (1, 0). Now consider $T$ to be the special case of $p = 0$
and $q = 1$ in a family of transformation $T_{pq}$, where $T_{pq}$
transforms the pair $(a, b)$ according to $a \leftarrow bq + aq + ap$
and $b \leftarrow bp + aq$. Show that if we apply such a
transformation $T_{pq}$ twice, the effect is the same as using a
single transformation $T_{p'q'}$ of the same form, and computer $p'$
and $q'$ in terms of $p$ and $q$. This gives us an explicit way to
square these transformations, and thus we can compute $T^n$ using
successive squaring, as in the ~fast-expt~ procedures. Put this all
together to complete the following procedure, which runs in a
logarithmic number of steps:
#+end_quote

#+begin_src scheme
  (define (fib n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0)
           b)
          ((even? count)
           (fib-iter a
                     b
                     ⟨??⟩  ;compute p'
                     ⟨??⟩  ;compute q'
                     (/ count 2)))
          (else
           (fib-iter (+ (* b q)
                        (* a q)
                        (* a p))
                     (+ (* b p)
                        (* a q))
                     p
                     q
                     (- count 1)))))

#+end_src

*** 1.2.5 Greatest Common Divisors
Exercise:
#+begin_quote
Exercise 1.20: The process that a procedure generates is of course
dependent on the rules used by the interpreter. As an example,
consider the iterative gcd procedure given above. Suppose we were to
interpret this procedure using normal-order evaluation, as discussed
in 1.1.5. (The normal-order-evaluation rule for if is described in
Exercise 1.5.) Using the substitution method (for normal order),
illustrate the process generated in evaluating (gcd 206 40) and
indicate the remainder operations that are actually performed. How
many remainder operations are actually performed in the normal-order
evaluation of (gcd 206 40)? In the applicative-order evaluation?
#+end_quote

Answer:

Let us repeat some older stuff.

*Evaluation a combination (applicative order)*: The interpreter
evaluates a combination by:
1. Evaluating the subexpression of the combination (recursion!);
2. Applying the procedure that is the value of the leftmost
   subexpression (the operator) to the arguments that are the values
   of the other subexpressions (the operands).


What does it mean to apply a procedure?

*Procedure application*: for primitive procedures we can assume that
the mechanism is built into the interpreter. For compound procedurees:
evaluate the body of the procedure with each formal parameter
*replaced* by the corresponding argument. Given the replacing this is
known as ``substitution model''.

A different model:

*Evaluation a combination (normal order evaluation)*: evaluate the
operan only when needed

#+begin_src emacs-lisp
  (defun gcd (a b)
    (if (= b 0)
        a
      (gcd b (% a b))))
#+end_src

#+begin_src emacs-lisp
  ;; normal order evaluation

  (gcd 206 40)
  (if (= 40 0)
      206
    (gcd 40 (% 206 40)))

  (gcd 40 (% 206 40)))
  (if (= (% 206 40) 0) ;;1
      40
    (gcd (% 206 40) (% 40 (% 206 40))))

  (gcd (% 206 40) (% 40 (% 206 40)))
  (if (= (% 40 (% 206 40)) 0) ;; 2, 3
      (% 206 40)
    (gcd (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))

  (gcd (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40))))
  (if (= (% (% 206 40) (% 40 (% 206 40))) 0) ;; 4, 5, 6, 7
      (% 40 (% 206 40))
    (gcd (% (% 206 40) (% 40 (% 206 40)))
         (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))))

  (gcd (% (% 206 40) (% 40 (% 206 40)))
       (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))
  (if (= (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))) 0) ;; 8, 9, 10, 11, 12, 13, 14
        (% (% 206 40) (% 40 (% 206 40)))
      (gcd (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40))))
           (% (% (% 206 40) (% 40 (% 206 40))) (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))))

  (% (% 206 40) (% 40 (% 206 40))) ;; 15, 16, 17, 18
#+end_src


#+begin_src emacs-lisp
  ;; applicative order evaluation
  (defun gcd (a b)
    (if (= b 0)
        a
      (gcd b (% a b))))

  (gcd 206 40)
  (if (= 40 0)
      206
    (gcd 40 (% 206 40)))

  (gcd 40 (% 206 40)) ; 1
  (gcd 40 6)
  (if (= 6 0)
      40
    (gcd 6 (% 40 6)))

  (gcd 6 (% 40 6)) ; 2
  (gcd 6 4)
  (if (= 4 0)
      6
    (gcd 4 (% 6 4)))

  (gcd 4 (% 6 4)) ; 3
  (gcd 4 2)
  (if (= 2 0)
      4
    (gcd 2 (% 4 2)))

  (gcd 2 (% 4 2)) ; 4
  (gcd 2 0)
  (if (= 0 0)
      2
    (gcd 0 (% 2 0)))

  2
#+end_src

*** 1.2.6 Example: Testing for Primality
Here is one way to find whether a number is prime:
#+begin_src emacs-lisp
  (defun smallest-divisor (n)
    (find-divisor n 2))

  (defun find-divisor (n test-divisor)
    (cond ((> (square test-divisor) n)
           n)
          ((dividesp test-divisor n)
           test-divisor)
          (t (find-divisor
              n
              (+ test-divisor 1)))))

  (defun dividesp (a b)
    (= (% b a ) 0))

  (defun primep (n)
    (= n (smallest-divisor n)))
#+end_src

In the worst case scenario we have to call test-divisor $\sqrt{n}$
times. So, the order of growth is $\Theta (\sqrt{n})$.


The authors also present a $\Theta (log(n))$ algorithm to tests
primality. It is based on the so-called Fermat's Little Theorem.

- Fermat's Little Theorem: If $n$ is a prime number and $a$ is any
  positive integer less than n, then $a$ raised ot the $n^{th}$ power
  is congruent to $a$ modulo $n$.

#+begin_src emacs-lisp
  (defun expmod (base exp m)
    (cond ((= exp 0) 1)
          ((evenp exp)
           (%
            (square (expmod base (/ exp 2) m))
            m))
          (t
           (%
            (* base (expmod base (- exp 1) m))
            m))))

  (defun try-it (a n)
    (= (expmod a n n) a))

  (defun fermat-test (n)
    (try-it (+ 1 (random (- n 1))) n))

  (defun fast-primep (n times)
    (cond ((= times 0) t)
          ((fermat-test n)
           (fast-primep n (- times 1)))
          (t nil)))

  (defun evenp (n)
    (= (% n 2) 0)
#+end_src
*** ex 1.21
Exercise:
#+begin_quote
Use the smallest-divisor procedure to find the smallest divisor of
each of the following numbers: 199, 1999, 19999.
#+end_quote

Answer:
#+begin_src emacs-lisp
  (smallest-divisor 199)   ;; => 199
#+end_src

This is the series of procedure calls:
#+begin_src emacs-lisp
  (smallest-divisor 199)
  (find-divisor 199 2)
  (cond ((> (square 2) 199)
         199)
        ((dividesp 2 199)
         2)
        (t (find-divisor
            199
            (+ 2 1))))
  (find-divisor 199 3)
  (find-divisor 199 4)
  (find-divisor 199 5)
  (find-divisor 199 6)
  (find-divisor 199 7)
  (find-divisor 199 8)
  (find-divisor 199 9)
  (find-divisor 199 10)
  (find-divisor 199 11)
  (find-divisor 199 12)
  (find-divisor 199 13)
  (find-divisor 199 14)
  (find-divisor 199 15)
  199
#+end_src


#+begin_src emacs-lisp
  (smallest-divisor 1999)  ;; => 1999
#+end_src

This is the series of procedure calls:
#+begin_src emacs-lisp
  (smallest-divisor 1999)
  (find-divisor 1999 2)

  (cond ((> (square 2) 1999)
         1999)
        ((dividesp 2 1999)
         2)
        (t (find-divisor
               1999
               (+ 2 1))))

  (find-divisor 1999 3)

  (find-divisor 1999 4)

  ;; ...

  (find-divisor 1999 45)

  1999
#+end_src



#+begin_src emacs-lisp
  (smallest-divisor 19999) ;; => 7
#+end_src
This is the series of procedure calls:
#+begin_src emacs-lisp
  (smallest-divisor 19999)

  (find-divisor 19999 2)

  (find-divisor 19999 3)

  (find-divisor 19999 4)

  (find-divisor 19999 5)

  (find-divisor 19999 6)

  (find-divisor 19999 7)
  7
#+end_src
*** ex 1.22
#+begin_quote
Most Lisp implementations include a primitive called runtime that
returns an integer that specifies the amount of time the system has
been running (measured, for example, in microseconds). The following
timed-prime-test procedure, when called with an integer n, prints n
and checks to see if n is prime. If n is prime, the procedure prints
three asterisks followed by the amount of time used in performing the
test.

#+begin_src scheme
  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))
  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime)
                         start-time))))
  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
#+end_src

Using this procedure, write a procedure search-for-primes that checks
the primality of consecutive odd integers in a specified range. Use
your procedure to find the three smallest primes larger than 1000;
larger than 10,000; larger than 100,000; larger than 1,000,000. Note
the time needed to test each prime. Since the testing algorithm has
order of growth of $\theta (\sqrt{n})$, you should expect that testing
for primes around 10,000 should take about $\sqrt{10}$ times as long
as testing for primes around 1000. Do your timing data bear this out?
How well do the data for 100,000 and 1,000,000 support the $\theta
(\sqrt{n})$ prediction? Is your result compatible with the notion that
programs on your machine run in time proportional to the number of
steps required for the computation?
#+end_quote


Answer:

For this one I'm using (Dr)Racket, which provides a version of Scheme
specifically modified in order to be used for SICP's code (useful here
in that it provides ~runtime~).

#+begin_src scheme
  #lang sicp
  (define (square x)
    (* x x))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n)
           n)
          ((divides? test-divisor n)
           test-divisor)
          (else (find-divisor
                 n
                 (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime)
                         start-time))))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

  (timed-prime-test 199) ;; 199 *** 6
#+end_src

#+begin_src scheme
  (define (search-for-primes begin end)
    (cond ((< begin end)
           (timed-prime-test begin)
           (search-for-primes (+ 2 begin) end))))
#+end_src

#+begin_src scheme
  (search-for-primes 1001 1021)
  ;; 1001
  ;; 1003
  ;; 1005
  ;; 1007
  ;; 1009 *** 5
  ;; 1011
  ;; 1013 *** 4
  ;; 1015
  ;; 1017
  ;; 1019 *** 3

  (search-for-primes 10001 10050)
  ;; 10001
  ;; 10003
  ;; 10005
  ;; 10007 *** 12
  ;; 10009 *** 9
  ;; 10011
  ;; 10013
  ;; 10015
  ;; 10017
  ;; 10019
  ;; 10021
  ;; 10023
  ;; 10025
  ;; 10027
  ;; 10029
  ;; 10031
  ;; 10033
  ;; 10035
  ;; 10037 *** 8
  ;; 10039 *** 8
  ;; 10041
  ;; 10043
  ;; 10045
  ;; 10047
  ;; 10049

  (search-for-primes 100001 100050)
  ;; 100001
  ;; 100003 *** 22
  ;; 100005
  ;; 100007
  ;; 100009
  ;; 100011
  ;; 100013
  ;; 100015
  ;; 100017
  ;; 100019 *** 21
  ;; 100021
  ;; 100023
  ;; 100025
  ;; 100027
  ;; 100029
  ;; 100031
  ;; 100033
  ;; 100035
  ;; 100037
  ;; 100039
  ;; 100041
  ;; 100043 *** 21
  ;; 100045
  ;; 100047
  ;; 100049 *** 20

  (search-for-primes 1000001 1000051)

  ;; 1000001
  ;; 1000003 *** 79
  ;; 1000005
  ;; 1000007
  ;; 1000009
  ;; 1000011
  ;; 1000013
  ;; 1000015
  ;; 1000017
  ;; 1000019
  ;; 1000021
  ;; 1000023
  ;; 1000025
  ;; 1000027
  ;; 1000029
  ;; 1000031
  ;; 1000033 *** 63
  ;; 1000035
  ;; 1000037 *** 62
  ;; 1000039 *** 65
  ;; 1000041
  ;; 1000043
  ;; 1000045
  ;; 1000047
  ;; 1000049
#+end_src



# #+begin_quote
# you should expect that testing for primes around 10,000 should take
# about $\sqrt{10}$ times as long as testing for primes around 1000. Do
# your timing data bear this out?
# #+end_quote
# The numbers after 1000 took 5, 4, 3. The numbers after 10000 took 12,
# 9 and 8. (I don't know why time decreases with bigger numbers).

# Now, (* 5 (sqrt 10)) 15 something, (* 4 (sqrt 10)) is 12 something, (*
# 3 (sqrt 10)) is 9 something. So, yeah, more or less...


# #+begin_quote
# How well do the data for 100,000 and 1,000,000 support the $\theta
# (\sqrt{n})$ prediction?
# #+end_quote

# The numbers after 100000 took 22 and 21. The numbers after 1000001
# took 79, 63, and 62.

# (* 22 (sqrt 10)) is 69 something. (* 21 (sqrt 10)) is 66 something. So
# yeah, again, more or less...

# #+begin_quote
# Is your result compatible with the notion that programs on your
# machine run in time proportional to the number of steps required for
# the computation?
# #+end_quote
# I don't see why not.

In today's computers these operations take microseconds. I have been
told that the accuracy of these measurements is not to be trusted,
given the small size of these amounts of time.

We can, however, use biggers numbers.

Computing ~(timed-prime-test 34888314291653)~ --- I've chosen randomly
--- took 642.775 milliseconds. These should be more than enough to
have an acceptable accuracy in our benchmarking. Let's start our
experiments from here.

Let's find the first three primes starting from 34888314291653.

#+begin_src scheme
  ;; 34888314291653 *** 701102
  ;; 34888314291655
  ;; 34888314291657
  ;; 34888314291659
  ;; 34888314291661
  ;; 34888314291663
  ;; 34888314291665
  ;; 34888314291667 *** 895322
  ;; 34888314291669
  ;; 34888314291671
  ;; 34888314291673
  ;; 34888314291675
  ;; 34888314291677
  ;; 34888314291679
  ;; 34888314291681
  ;; 34888314291683
  ;; 34888314291685
  ;; 34888314291687
  ;; 34888314291689
  ;; 34888314291691
  ;; 34888314291693
  ;; 34888314291695
  ;; 34888314291697
  ;; 34888314291699
  ;; 34888314291701
  ;; 34888314291703
  ;; 34888314291705
  ;; 34888314291707
  ;; 34888314291709
  ;; 34888314291711
  ;; 34888314291713 *** 630255
#+end_src

Now we multiply 34888314291653 by ten and find the first three primes
starting from there. 34888314291653 times 10 is 348883142916530.

#+begin_src scheme
  ;; 348883142916531
  ;; 348883142916533 *** 2027795
  ;; 348883142916535
  ;; 348883142916537
  ;; 348883142916539
  ;; 348883142916541
  ;; 348883142916543
  ;; 348883142916545
  ;; 348883142916547
  ;; 348883142916549
  ;; 348883142916551
  ;; 348883142916553
  ;; 348883142916555
  ;; 348883142916557
  ;; 348883142916559
  ;; 348883142916561
  ;; 348883142916563
  ;; 348883142916565
  ;; 348883142916567
  ;; 348883142916569
  ;; 348883142916571
  ;; 348883142916573
  ;; 348883142916575
  ;; 348883142916577
  ;; 348883142916579
  ;; 348883142916581
  ;; 348883142916583
  ;; 348883142916585
  ;; 348883142916587
  ;; 348883142916589
  ;; 348883142916591
  ;; 348883142916593
  ;; 348883142916595
  ;; 348883142916597
  ;; 348883142916599
  ;; 348883142916601
  ;; 348883142916603
  ;; 348883142916605
  ;; 348883142916607
  ;; 348883142916609
  ;; 348883142916611
  ;; 348883142916613 *** 1893341
  ;; 348883142916615
  ;; 348883142916617
  ;; 348883142916619
  ;; 348883142916621
  ;; 348883142916623
  ;; 348883142916625
  ;; 348883142916627
  ;; 348883142916629
  ;; 348883142916631
  ;; 348883142916633
  ;; 348883142916635
  ;; 348883142916637
  ;; 348883142916639
  ;; 348883142916641
  ;; 348883142916643
  ;; 348883142916645
  ;; 348883142916647
  ;; 348883142916649
  ;; 348883142916651
  ;; 348883142916653
  ;; 348883142916655
  ;; 348883142916657
  ;; 348883142916659
  ;; 348883142916661
  ;; 348883142916663
  ;; 348883142916665
  ;; 348883142916667
  ;; 348883142916669
  ;; 348883142916671
  ;; 348883142916673
  ;; 348883142916675
  ;; 348883142916677
  ;; 348883142916679
  ;; 348883142916681
  ;; 348883142916683
  ;; 348883142916685
  ;; 348883142916687
  ;; 348883142916689
  ;; 348883142916691
  ;; 348883142916693
  ;; 348883142916695
  ;; 348883142916697
  ;; 348883142916699
  ;; 348883142916701
  ;; 348883142916703
  ;; 348883142916705
  ;; 348883142916707
  ;; 348883142916709
  ;; 348883142916711
  ;; 348883142916713
  ;; 348883142916715
  ;; 348883142916717
  ;; 348883142916719
  ;; 348883142916721
  ;; 348883142916723
  ;; 348883142916725
  ;; 348883142916727
  ;; 348883142916729
  ;; 348883142916731
  ;; 348883142916733
  ;; 348883142916735
  ;; 348883142916737
  ;; 348883142916739 *** 1809663
#+end_src

(* 701102 (sqrt 10)) = 2217079.192099371. With 348883142916533 we
took 2027795, so the prediction is roughly correct.


Let us now test whether the number we find after (*
10 348883142916530) and those after (* 10 10 348883142916530) fulfill
the prediction too.

#+begin_quote
3488831429165323 *** 5971326
#+end_quote

#+begin_src scheme
  (search-for-primes 3488831429165301 3488831429165401)
  ;; ...
  ;; 3488831429165323 *** 5971326
  ;; ...
#+end_src

#+begin_src scheme
  (search-for-primes 34888314291653011 34888314291653511)
  ;; ...
  ;; 34888314291653021 *** 16052655
  ;; ...
#+end_src

(* 5971326 (sqrt 10)) 18882990.81138261. Again, the prediction seems
roughly correct.

*** ex 1.23
#+begin_quote
The ~smallest-divisor~ procedure shown at the start of this section
does lots of needless testing: After it checks to see if the number is
divisible by 2 there is no point in checking to see if it is divisible
by any larger even numbers. This suggests that the values used for
~test-divisor~ should not be 2, 3, 4, 5, 6, …, but rather 2, 3, 5, 7,
9, …. To implement this change, define a procedure next that returns 3
if its input is equal to 2 and otherwise returns its input
plus 2. Modify the ~smallest-divisor~ procedure to use ~(next
test-divisor)~ instead of ~(+ test-divisor 1)~. With
~timed-prime-test~ incorporating this modified version of
~smallest-divisor~, run the test for each of the 12 primes found in
Exercise 1.22. Since this modification halves the number of test
steps, you should expect it to run about twice as fast. Is this
expectation confirmed? If not, what is the observed ratio of the
speeds of the two algorithms, and how do you explain the fact that it
is different from 2?
#+end_quote

Answer:
#+begin_src scheme
  (define (smallest-divisor-mod n)
    (find-divisor-mod n 2))

  (define (find-divisor-mod n test-divisor)
    (cond ((> (square test-divisor) n)
           n)
          ((divides? test-divisor n)
           test-divisor)
          (else (find-divisor
                 n
                 (next test-divisor)))))

  ;; ...

  (define (next n)
    (if (= n 2)
        3
        (+ n 1)))

  (define (prime?-mod n)
    (= n (smallest-divisor-mod n)))

  (define (timed-prime-test-mod n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test-mod n start-time)
    (if (prime?-mod n)
        (report-prime (- (runtime)
                         start-time))))
#+end_src

I haven't observed any relevant difference with the numbers I have
tested. I'm not sure why that is so. One possible explanation is that
the numbers I have tested are too small. Another possible explanation
is that Racket performs some optimizations.
*** ex 1.25
- check fn 46
** 1.3 Formulating Abstractions with Higher-Order Procedures
*** 1.3.1 Procedures as arguments
*** Exercise 1.29
#+begin_quote
Simpson’s Rule is a more accurate method of numerical integration than
the method illustrated above. Using Simpson’s Rule, the integral of a
function $f$ between a and b is approximated as

$\frac{h}{3} (y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_{n-2} +
2y_{n-1} + y_n)$,


where $h = (b - a) / n$, for some even integer $n$, and $y_k = f(a +
kh)$. (Increasing $n$ increases the accuracy of the approximation.)
Define a procedure that takes as arguments $f$, $a$, $b$, and $n$ and
returns the value of the integral, computed using Simpson's Rule. Use
your procedure to integrate ~cube~ between 0 and 1 (with $n = 100$ and
$n = 1000$), and compare the results to those of the ~integral~
procedure shown above.
#+end_quote


Answer:
#+begin_src scheme
  (define (integral f a b n)
    (define (next x)
      (if (x is odd)
          (...)
          (...)))
    (* (/ (/ (- b a ) n) 3)
       (+ y0
          (sum ...)
          yn)))
#+end_src

#+begin_src scheme
#lang sicp
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (cube x) (* x x x))

(define (integral f a b n)

    (define (f-mod) ;;<== takes not arg?!
      (define (f2 x)
        (* 2 (f x)))
      (define (f4 x)
        (* 4 (f x)))
      (if (= (remainder a 2) 0)
          f2
          f4))

    (define (next x)
      (+ x
         1
         (* (+ x 1)
            (/ (- b a ) n))))

    (* (/ (/ (- b a ) n) 3)
       (+ (f 0)
          (sum f-mod
               (+ (+ 1 a)
                  (* (+ 1 a)
                     (/ (- b a ) n)))
               next
               b)
          (f (+ n
                (* n
                   (/ (- b a ) n)))))))

(define (integral-first f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
#+end_src

#+begin_src scheme
  #lang sicp
  (define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

  (define (cube x) (* x x x))

  (define (integral f a b n)
    (define (f-mod x)
      (define (f2 x)
        (* 2 (f x)))
      (define (f4 x)
        (* 4 (f x)))
      (cond ((= x 0) (f x))
            ((= x n) (f x))
            ((= (remainder (- x a) 2) 0) (f2 x))
            (else (f4 x))))
    (define (next x)
      (+ x
         1
         (* (+ x 1) (/ (- b a) n))))
    (* (/ (/ (- b a) n) 3)
       (sum f-mod a next b)
       n))

  ;;(integral cube 0 1 1000) ; ==> 0 :(
#+end_src

#+begin_src scheme
  #lang sicp
  (define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

  (define (cube x) (* x x x))

  (define (integral f a b n)
    (define (f-mod x)
      (define (f2 x)
        (* 2 (f x)))
      (define (f4 x)
        (* 4 (f x)))
      (cond ((= x 0) (f x))
            ((= x n) (f x))
            ((= (remainder (- x a) 2) 0) (f2 x))
            (else (f4 x))))

    (define (next x)
      (+ x 1))

    (* (/ (/ (- b a) n) 3)
       (sum f-mod (* a (/ (- b a) n)) next b)
       n))

  (integral cube 0 1 1000) ;; 1*1/3 :(
#+end_src

#+begin_src scheme
  #lang sicp
  (define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

  (define (cube x) (* x x x))

  (define (integral f a b n)

    (define (f-mod x)
      (define (f2 x)
        (* 2 (f x)))
      (define (f4 x)
        (* 4 (f x)))
      (cond ((= x a) (f x))
            ((= (- (/ x (/ (- b a) n)) a) n) (f x))
            ((= (remainder (- (/ x (/ (- b a) n)) a) 2) 0) (f2 x))
            (else (f4 x))))

    (define (next x)
      (+ x
         (/ (- b a) n)))

    (* (/ (/ (- b a) n) 3)
       (sum f-mod
            a
            next
            (+ a (* n (/ (- b a) n))))))

  (integral cube 0 1 100);; 1/4 :)
#+end_src

*** Exercise 1.30
Exercise:
#+begin_quote
The sum procedure above generates a linear recursion. The procedure
can be rewritten so that the sum is performed iteratively. Show how to
do this by filling in the missing expressions in the following
definition:
#+begin_src scheme
  (define (sum term a next b)
    (define (iter a result)
      (if ⟨??⟩
          ⟨??⟩
          (iter ⟨??⟩ ⟨??⟩)))
    (iter ⟨??⟩ ⟨??⟩))
#+end_src
#+end_quote

Answer:

#+begin_src scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
#+end_src

*** Exercise 1.31
Exercise:
#+begin_quote
1) The sum procedure is only the simplest of a vast number of similar
   abstractions that can be captured as higher-order procedures.[fn: The
   intent of Exercise 1.31 through Exercise 1.33 is to demonstrate the
   expressive power that is attained by using an appropriate abstraction
   to consolidate many seemingly disparate operations. However, though
   accumulation and filtering are elegant ideas, our hands are somewhat
   tied in using them at this point since we do not yet have data
   structures to provide suitable means of combination for these
   abstractions. We will return to these ideas in 2.2.3 when we show how
   to use sequences as interfaces for combining filters and accumulators
   to build even more powerful abstractions. We will see there how these
   methods really come into their own as a powerful and elegant approach
   to designing programs.] Write an analogous procedure called product
   that returns the product of the values of a function at points over a
   given range. Show how to define factorial in terms of product. Also
   use product to compute approximations to π using the formula...

   $\frac{\pi}{4} = \frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \cdot
   \dots}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \cdot \dots}$

2) If your product procedure generates a recursive process, write
   one that generates an iterative process. If it generates an
   iterative process, write one that generates a recursive process.
#+end_quote

Answer:

Here is ~product~.
#+begin_src scheme
  (define (product term a next b)
    (if (> a b)
        1
        (* (term a) (product term (next a) next b))))
#+end_src

Here is ~factorial~ defined in terms of ~product~.
#+begin_src scheme
  (define (factorial n)
    (define (inc x) (+ 1 x))
    (define (indentity x) x)
    (product identity 1 inc n))
#+end_src

Here is one way of computing an approximation to $\pi$.
#+begin_src scheme
  (define (product* begin end)
    (define (identity x) x)
    (define (inc2 x) (+ 2 x))
    (product identity begin inc2 end))

  (* (/ (* 2 (product* 4 8) (product* 4 6))
        (square (product* 3 7)))
     4.0)
#+end_src

My ~product~ procedure generates a recursive process ($\Theta(n)$ in
time and space). Here is a ~product~ that generates an iterative
process ($\Theta(n)$ in time, $\Theta(1)$ in space).

#+begin_src scheme
  (define (product term a next b)
    (define (iter a result)
      (if (> a b)
          result
          (iter (next a) (* (term a) result))))
    (iter a 1))
#+end_src

We can notice that we start our iteration multiplying by 1, whereas we
were /ending/ our recursion multiplying by 1. (Analogously with ~sum~
and 0).

*** Exercise 1.32
#+begin_quote
1) Show that ~sum~ and ~product~ (Exercise 1.31) are both special cases
   of a still more general notion called ~accumulate~ that combines a
   collection of terms, using some general accumulation function:

   #+begin_src scheme
     (accumulate combiner null-value term a next b)
   #+end_src

   ~Accumulate~ takes as arguments the same term and range specifications
   as ~sum~ and ~product~, together with a ~combiner~ procedure (of two
   arguments) that specifies how the current term is to be combined with
   the accumulation of the preceding terms and a null-value that
   specifies what base value to use when the terms run out. Write
   accumulate and show how sum and product can both be defined as simple
   calls to accumulate.

2) If your accumulate procedure generates a recursive process, write
   one that generates an iterative process. If it generates an
   iterative process, write one that generates a recursive process.
#+end_quote

Answer:

By looking at the recursive version of ~sum~ and ~product~, we can
observe that only certain elements in the two bodies are
different. They are:
- The first expression after the if;
- The procedure applied in the tail call;

As far as I can tentatively see, this means that the concepts
expressed ~sum~ and ~product~ belong to a more general concept.

This latter concept /abstracts/ over the two parts of the body
mentioned. The first abstraction is an abstraction over a numeric
value. The second abstraction is an abstraction over a procedure.

This more general concept can itself be expressed by a procedure
definition

#+begin_src scheme
  (define (accumulate combiner null-value term a next b)
    (if (> a b)
        null-value
        (combiner (term a)
                  (accumulate combiner null-value term (next a) next b))))
#+end_src

#+begin_src scheme
  (sum identity 1 inc 5) ;; => 15
  (accumulate + 0 identity 1 inc 5) ;; => 15

  (product identity 2 inc 9) ;; => 362880
  (accumulate * 1 identity 2 inc 9) ;; => 362880
#+end_src

My accumulate generate a recursive process. Here is an iterative
version:
#+begin_src scheme
  (define (accumulate combiner null-value term a next b)
    (define (iter a result)
      (if (> a b)
          result
          (iter (next a) (combiner (term a) result))))
    (iter a null-value))
#+end_src

*** Exercise 1.33
Exercise:
#+begin_quote
You can obtain an even more general version of ~accumulate~ (Exercise
1.32) by introducing the notion of a ~filter~ on the terms to be
combined. That is, combine only those terms derived from values in the
range that satisfy a specified condition. The resulting
~filtered-accumulate~ abstraction takes the same arguments as
accumulate, together with an additional predicate of one argument that
specifies the filter. Write ~filtered-accumulate~ as a procedure. Show
how to express the following using ~filtered-accumulate~:
1. the sum of the squares of the prime numbers in the interval ~a~ to ~b~
   (assuming that you have a ~prime?~ predicate already written)
2. the product of all the positive integers less than $n$ that are
   relatively prime to $n$j (i.e., all positive integers $i < n$ such
   that $GCD(i,n)=1$).
#+end_quote


Answer:

#+begin_src scheme
  (define (filtered-accumulate combiner filter null-value term a next b)
  (cond ((> a b) null-value)
        ((filter a) (combiner (term a)
                              (filtered-accumulate combiner filter null-value term (next a) next b)))
        (else (filtered-accumulate combiner filter null-value term (next a) next b))))
#+end_src

#+begin_src scheme
  (define (sum-of-the-squares-of-primes a b)
    (filtered-accumulate + prime? 0 square a inc2 b))
#+end_src

#+begin_src scheme
  (define (product-int-less-than-rel-prime-to n)
    (define (rel-prime-to-n x)
      (= (gcd x n)
         1))
    (filtered-accumulate * rel-prime-to-n 1 1 inc1 (- n 1)))
#+end_src

*** Exercise 1.34
#+begin_quote
Suppose we define the procedure

#+begin_src scheme
  (define (f g) (g 2))
#+end_src

Then we have

#+begin_src scheme
  (f square)
  4

  (f (lambda (z) (* z (+ z 1))))
  6
#+end_src

What happens if we (perversely) ask the interpreter to evaluate the
combination (f f)? Explain?
#+end_quote

Answer:

According to the substitution model:
#+begin_src
(f f)
(f 2)
(2 2)
#+end_src

In `(2 2)`, `2` is used as if it denoted a procedure. But `2` does not
denote a procedure. `2` denotes a number. So, I predict that the
interpreter will complain about this.

In fact, when trying to evaluate the combination, DrRacket says:
#+begin_quote
application: not a procedures;
expected a procedures that can be applied to arguments
given: 2
#+end_quote

*** Exercise 1.41
#+begin_quote
Define a procedure double that takes a procedure of one argument as
argument and returns a procedure that applies the original procedure
twice. For example, if ~inc~ is a procedure that adds 1 to its
argument, then ~(double inc)~ should be a procedure that adds 2. What
value is returned by

#+begin_src scheme
  (((double (double double)) inc) 5)
#+end_src
#+end_quote

Answer:

#+begin_src scheme
  ;; (((double (double double)) inc) 5)

  ;; (double inc) => (lambda (x) (inc (inc x)))

  ;; (double double) => (lambda (x) (double (double x)))

  ;; (double (double double)) =>
  ;; (lambda (x) ((lambda (x) (double (double x)))
  ;;             ((lambda (x) (double (double x))) x)))

  ;; so:

  ((double (double double) inc))

  ;; =>

  ((lambda (x) (double (double x)))
   (double (double inc)))

  ;; =>

  ((lambda (x) (double (double x)))
   (double (lambda (x) (inc (inc x)))))

  ;; =>

  ((lambda (x) (double (double x)))
   (lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x))))

  ;; =>

  (double (double (lambda (x) ((lambda (x) (inc (inc x)))
                               ((lambda (x) (inc (inc x))) x)))))

  ;; =>

  (double (lambda (x)
            ((lambda (x) ((lambda (x) (inc (inc x)))
                          ((lambda (x) (inc (inc x))) x)))
             ((lambda (x) ((lambda (x) (inc (inc x)))
                           ((lambda (x) (inc (inc x))) x))) x))))

  ;; =>

  (lambda (x) ((lambda (x)
                 ((lambda (x) ((lambda (x) (inc (inc x)))
                               ((lambda (x) (inc (inc x))) x)))
                  ((lambda (x) ((lambda (x) (inc (inc x)))
                                ((lambda (x) (inc (inc x))) x))) x)))
               ((lambda (x)
                  ((lambda (x) ((lambda (x) (inc (inc x)))
                                ((lambda (x) (inc (inc x))) x)))
                   ((lambda (x) ((lambda (x) (inc (inc x)))
                                 ((lambda (x) (inc (inc x))) x))) x)))
                x)))

  ;; now let's apply that lambda to 5:
  ((lambda (x) ((lambda (x)
                  ((lambda (x) ((lambda (x) (inc (inc x)))
                                ((lambda (x) (inc (inc x))) x)))
                   ((lambda (x) ((lambda (x) (inc (inc x)))
                                 ((lambda (x) (inc (inc x))) x))) x)))
                ((lambda (x)
                   ((lambda (x) ((lambda (x) (inc (inc x)))
                                 ((lambda (x) (inc (inc x))) x)))
                    ((lambda (x) ((lambda (x) (inc (inc x)))
                                  ((lambda (x) (inc (inc x))) x))) x)))
                 x))) 5)

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x)
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x)))
       ((lambda (x) ((lambda (x) (inc (inc x)))
                     ((lambda (x) (inc (inc x))) x))) x)))
    5))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    ((lambda (x) ((lambda (x) (inc (inc x)))
                  ((lambda (x) (inc (inc x))) x))) 5)))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    ((lambda (x) (inc (inc x)))
     ((lambda (x) (inc (inc x))) 5))))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    ((lambda (x) (inc (inc x)))
     (inc (inc 5)))))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    ((lambda (x) (inc (inc x)))
     (inc 6))))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    ((lambda (x) (inc (inc x)))
     7)))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    (inc (inc 7))))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    (inc 8)))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x)))
    9))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) (inc (inc x)))
    ((lambda (x) (inc (inc x))) 9)))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) (inc (inc x)))
    (inc (inc 9))))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) (inc (inc x)))
    (inc 10)))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   ((lambda (x) (inc (inc x)))
    11))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   (inc (inc 11)))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   (inc 12))

  ;; =>

  ((lambda (x)
     ((lambda (x) ((lambda (x) (inc (inc x)))
                   ((lambda (x) (inc (inc x))) x)))
      ((lambda (x) ((lambda (x) (inc (inc x)))
                    ((lambda (x) (inc (inc x))) x))) x)))
   13)

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   ((lambda (x) ((lambda (x) (inc (inc x)))
                 ((lambda (x) (inc (inc x))) x))) 13))

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   ((lambda (x) (inc (inc x)))
    ((lambda (x) (inc (inc x))) 13)))


  ;; =>
  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   ((lambda (x) (inc (inc x)))
    (inc (inc 13))))

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   ((lambda (x) (inc (inc x)))
    (inc 14)))

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   ((lambda (x) (inc (inc x)))
    15))

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   (inc (inc 15)))

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   (inc 16))

  ;; =>

  ((lambda (x) ((lambda (x) (inc (inc x)))
                ((lambda (x) (inc (inc x))) x)))
   17)

  ;; =>

  ((lambda (x) (inc (inc x)))
   ((lambda (x) (inc (inc x))) 17))

  ;; =>

  ((lambda (x) (inc (inc x)))
   (inc (inc 17)))

  ;; =>

  ((lambda (x) (inc (inc x)))
   (inc 18))

  ;; =>

  ((lambda (x) (inc (inc x)))
   19)

  ;; =>

  (inc (inc 19))

  ;; =>

  (inc 20)

  ;; =>

  21

#+end_src
*** Exercise 1.42
Exercise:

#+begin_quote
Let $f$ and $g$ be two one-argument functions. The /composition/ $f$
after $g$ is defined to be the function $x \mapsto f(g(x))$. Define a
procedure ~compose~ that implements composition. For example, if ~inc~
is a procedure that adds 1 to its argument,

#+begin_src scheme
  ((compose square inc) 6)
  49
#+end_src
#+end_quote

Answer:

#+begin_src scheme
  (define (compose f1 f2)
    (lambda (x) (f1 (f2 x))))
#+end_src

*** Exercise 1.43
Exercise:

#+begin_quote
If $f$ is a numerical function and $n$ is a positive integer, then we
can form the $n^{th}$ repeated application of $f$, which is defined to
be the function whose value at $x$ is $f(f(…(f(x))…))$. For example,
if $f$ is the function $x \mapsto x+1$, then the $n^{th}$ repeated
application of $f$ is the function $x \mapsto x+n$. If $f$ is the
operation of squaring a number, then the $n^{th}$ repeated application
of $f$ is the function that raises its argument to the $2^{n}$ -th
power. Write a procedure that takes as inputs a procedure that
computes $f$ and a positive integer $n$ and returns the procedure that
computes the $n^{th}$ repeated application of $f$. Your procedure
should be able to be used as follows:

#+begin_src scheme
((repeated square 2) 5)
625
#+end_src

Hint: You may find it convenient to use ~compose~ from Exercise 1.42.
#+end_quote

Answer:

#+begin_src scheme
  (define (repeated f n)
    (cond ((= x 1) f)
          ((= x 2) (compose f f))
          (else (compose f (repeatedly-apply f (- n 1))))))
#+end_src

*** Exercise 1.44
#+begin_src scheme
  (define (smooth f)
    (lambda (x)
      (/ 3
         (+ (f (- x 0.01))
            (f x)
            (f (+ x 0.01))))))

  (define (10th-smoothed-f f)
    ((repeated smooth 10) f))
#+end_src

*** Exercise 1.46
#+begin_quote
Several of the numerical methods described in this chapter are
instances of an extremely general computational strategy known as
/iterative improvement/. Iterative improvement says that, to compute
something, we start with an initial guess for the answer, test if the
guess is good enough, and otherwise improve the guess and continue the
process using the improved guess as the new guess. Write a procedure
~iterative-improve~ that takes two procedures as arguments: a method
for telling whether a guess is good enough and a method for improving
a guess. ~Iterative-improve~ should return as its value a procedure that
takes a guess as argument and keeps improving the guess until it is
good enough. Rewrite the sqrt procedure of 1.1.7 and the fixed-point
procedure of 1.3.3 in terms of iterative-improve.
#+end_quote

Answer:

#+begin_src scheme
  (define (iterative-improve good-enough? improve)
    (define (iterative-improve-inner guess)
      (if (good-enough? guess) guess
          (iterative-improve-inner (improve guess))))
    (lambda (x) (iterative-improve-inner x)))
#+end_src

#+begin_src scheme
  (define (sqrt x)
    ((iterative-improve (lambda (guess)
                          (< (abs (- (square guess) x)) 0.001))
                        (lambda (guess)
                          (average guess (/ x guess))))
     1.0))
#+end_src
** Skipped exercises
List of the exercises I have skipped:
- 1.13.
- 1.19.
- 1.24. (It should be fairly easy).
- 1.25.
- 1.26.
- 1.27.
- 1.28.
- 1.35
- 1.36
- 1.37
- 1.38
- 1.39
- 1.45

* 2. Building Abstractions with Data
** 2.1 Introduction to Data Abstraction
*** Exercise 2.1
Exercise:

#+begin_quote
Define a better version of make-rat that handles both positive and
negative arguments. Make-rat should normalize the sign so that if the
rational number is positive, both the numerator and denominator are
positive, and if the rational number is negative, only the numerator
is negative.
#+end_quote

Answer:
#+begin_src scheme
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (if (or (and (> n 0) (> d 0))
              (and (< n 0) (< d 0)))
          (cons (/ (abs n) (abs g))
                (/ (abs d) (abs g)))
          (cons (- (/ (abs n) (abs g)))
                (/ (abs d) (abs g))))))

  (print-rat (make-rat 2 4))  ;; =>  1/2
  (print-rat (make-rat -2 4)) ;; => -1/2
  (print-rat (make-rat 2 -4)) ;; => -1/2
#+end_src
*** Exercise 2.2
#+begin_quote
Consider the problem of representing line segments in a plane. Each
segment is represented as a pair of points: a starting point and an
ending point. Define a constructor ~make-segment~ and selectors
~start-segment~ and ~end-segment~ that define the representation of
segments in terms of points. Furthermore, a point can be represented
as a pair of numbers: the $x$ coordinate and the $y$
coordinate. Accordingly, specify a constructor ~make-point~ and
selectors ~x-point~ and ~y-point~ that define this
representation. Finally, using your selectors and constructors, define
a procedure ~midpoint-segment~ that takes a line segment as argument
and returns its midpoint (the point whose coordinates are the average
of the coordinates of the endpoints). To try your procedures, you’ll
need a way to print points:

#+begin_src scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
#+end_src

#+end_quote

Answer:
#+begin_src scheme
  ;; constructor
  (define (make-segment s e) (cons s e))
  ;; selectors
  (define (start-segment x) (car x))
  (define (end-segment x) (cdr x))

  ;; constructor
  (define (make-point x y) (cons x y))
  ;; selectors
  (define (x-point x) (car x))
  (define (y-point x) (cdr x))

  (define (mid-point-segment line)
    (make-point (/ (+ (x-point (start-segment line))
                      (x-point (end-segment line)))
                   2)
                (/ (+ (y-point (start-segment line))
                      (y-point (end-segment line)))
                   2)))

  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  (print-point (mid-point-segment (make-segment (make-point 2 2) (make-point 6 4))))
#+end_src
*** Exercise 2.3
Exercise:

#+begin_quote
Implement a representation for rectangles in a plane. (Hint: You may
want to make use of Exercise 2.2.) In terms of your constructors and
selectors, create procedures that compute the perimeter and the area
of a given rectangle. Now implement a different representation for
rectangles. Can you design your system with suitable abstraction
barriers, so that the same perimeter and area procedures will work
using either representation?
#+end_quote

Answer:

I'm assuming the sides of the rectangle and the axes are parallel.

Sides are represented by segments whose points whose order is
clockwise, E.g., left-side: (bottom-point . top-point), top-side:
(left-point . right-point).

1st representation:
#+begin_src scheme
  (define (make-rec left-side top-side)
    (cons left top))

  (define (length rec)
    (let ((top-left-point (cdr (car rec)))
          (top-right-point (car (cdr rec))))
      (abs (- (x-point top-right-point)
              (x-point top-left-point)))))

  (define (width rec)
    (let ((bottom-left-point (car (car rec)))
          (top-left-point (cdr (car rec))))
      (abs (- (y-point top-left-point)
              (y-point bottom-left-point)))))
#+end_src

2nd representation:
#+begin_src scheme
  (define (make-rec right-side bottom-side)
    (cons right-side bottom-side))

  (define (length rec)
    (let ((bottom-left-point (cdr (cdr rec)))
          (bottom-right-point (car (cdr rec))))
      (abs (- (x-point bottom-right-point)
              (x-point bottom-left-point)))))

  (define (width rec)
    (let ((top-right-point (car (car rec)))
          (bottom-right-point (car (cdr rec))))
      (abs (- (y-point top-right-point)
              (y-point bottom-right-point)))))
#+end_src

- Procedures which work with both representations:
  #+begin_src scheme
    (define (perimeter rec)
      (* 2
         (+ (length rec) (width rec))))

    (define (area rec)
      (* (length rec) (width rec)))
  #+end_src
*** Exercise 2.4
*Exercise*:

#+begin_quote
Here is an alternative procedural representation of pairs. For this
representation, verify that (car (cons x y)) yields x for any objects
x and y.

#+begin_src scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))
#+end_src

What is the corresponding definition of cdr? (Hint: To verify that
this works, make use of the substitution model of 1.1.5.)
#+end_quote

*Answer*:

~(car (cons x y))~ is the application ~car~ to the result of the
application of ~cons~ to ~x~ and ~y~.

The application of ~cons~ to ~x~ and ~y~ is ~(lambda (m) (m x y))~.

So, the application of car to the application of ~cons~ to ~x~ and ~y~
is ~(car (lambda (m) (m x y)))~.

We can now take the body of ~car~ and replace each istance of ~z~ with
~(car (lambda (m) (m x y)))~. This gives us:

#+begin_src scheme
  ((lambda (m) (m x y)) (lambda (p q) p))
#+end_src

This latter combination is the application of ~(lambda (m) (m x y))~
to ~(lambda (p q) p)~.

We can now take the body of the first lambda (the procedure we are
applying) and replace each instance of ~m~ with the second lambda
(that to which we are applying the first lambda). This gives us:

#+begin_src scheme
  ((lambda (p q) p) x y)
#+end_src

This latter combination is the application of ~(lambda (p q) p)~ to
~x~ and ~y~. Which evaluates to ~x~.

The corresponding definition of ~cdr~ is:
#+begin_src scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+end_src
*** Exercise 2.5
#+begin_quote
Show that we can represent pairs of nonnegative integers using only
numbers and arithmetic operations if we represent the pair $a$ and $b$
as the integer that is the produce of $2^a3^b$. Give the corresponding
definitions of the procedures ~cons~, ~car~, and ~cdr~.
#+end_quote

#+begin_src scheme
  ;; from chapter 1 ******
  (define (square x) (* x x))

  (define (fast-expt b n)
    (cond ((= n 0)
           1)
          ((even? n)
           (square (fast-expt b (/ n 2))))
          (else
           (* b (fast-expt b (- n 1))))))

  (define (even? n)
    (= (remainder n 2) 0))
  ;; *********************

  (define (cons a b)
    (* (fast-expt 2 a)
       (fast-expt 3 b)))

  (define (car x)
    (define (car-iter x i)
      (if (not (even? x))
          i
          (car-iter (/ x 2) (+ i 1))))
    (car-iter x 0))

  (define (cdr x)
    (define (cdr-iter x i)
      (if (not (= (remainder x 3) 0))
          i
          (cdr-iter (/ x 3) (+ i 1))))
    (cdr-iter x 0))

  (define my-pair (cons 3 2)) ;; my-pair is now 72
  (car my-pair) ;; => 3
  (cdr my-pair) ;; => 2

  (cons 7 5)
  (define another-pair (cons 7 5)) ;; another-pair is now 31104
  (car another-pair) ;; => 7
  (cdr another-pair) ;; => 5
#+end_src

*** Exercise 2.6
Exercise:

#+begin_quote
In case representing pairs as procedures wasn’t mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as nonnegative integers are
concerned) by implementing 0 and the operation of adding 1 as

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

This representation is known as /Church numerals/, after its inventor,
Alonzo Church, the logician who invented the λ-calculus.

Define one and ~two~ directly (not in terms of ~zero~ and
~add-1~). (Hint: Use substitution to evaluate ~(add-1 zero)~). Give a
direct definition of the addition procedure ~+~ (not in terms of
repeated application of ~add-1~).
#+end_quote

Answer:

#+begin_src scheme
    (define zero (lambda (f) (lambda (x) x)))

  (define (zero-b f) (lambda (x) x))

  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))

  (add-1 zero)
  (lambda (f)
    (lambda (x)
      (f
       (((lambda (f)
           (lambda (x) x))
         f)
        x))))
  ;; =>
  (lambda (f)
    (lambda (x)
      (f
       ((lambda (x) x)
        x))))
  ;; => the following should be the def. of 1
  (lambda (f)
    (lambda (x)
      (f x)))
  ;; this above should be 1
  ;; So:
  (define one
    (lambda (f)
      (lambda (x)
        (f x))))

  ;; let's try to apply add-1 to what we think is 1
  (lambda (f)
    (lambda (x)
      (f
       (((lambda (f)
           (lambda (x)
             (f x))) f)
        x))))
  ;; =>
  (lambda (f)
    (lambda (x)
      (f
       ((lambda (x) (f x)) x))))
  ;; =>
  (lambda (f)
    (lambda (x)
      (f (f x))))
  ;; this one above should be 2.
  ;; So:
  (define two
    (lambda (f)
      (lambda (x)
        (f (f x)))))
#+end_src

Addition:
#+begin_src scheme
  (define add (lambda (n1)
                (lambda (n2)
                  (lambda (f)
                    (lambda (x)
                      ((n2 f) ((n1 f) x)))))))

  ;; or

  (define (add n1 n2)
    (lambda (f)
      (lambda (x)
        ((n2 f) ((n1 f) x)))))

  ;; lets try add 1 and 1
  ;; 1 is (lambda (f) (lambda (x) (f x)))

  (lambda (f)
    (lambda (x)
      (((lambda (f) (lambda (x) (f x))) f) (((lambda (f) (lambda (x) (f x))) f) x))))

  (lambda (f)
    (lambda (x)
      ((lambda (x) (f x)) (((lambda (f) (lambda (x) (f x))) f) x))))

  (lambda (f)
    (lambda (x)
      ((lambda (x) (f x)) ((lambda (x) (f x)) x))))

  (lambda (f)
    (lambda (x)
      ((lambda (x) (f x)) (f x))))

  (lambda (f)
    (lambda (x)
      ((lambda (x) (f x)) (f x))))

  (lambda (f)
    (lambda (x)
      ((f (f x)))))

  ;; lets try add 1 and 2
  ;; 1 is (lambda (f) (lambda (x) (f x)))
  ;; 2 is (lambda (f) (lambda (x) (f (f x))))

  (lambda (f)
    (lambda (x)
      (((lambda (f) (lambda (x) (f x))) f) (((lambda (f) (lambda (x) (f (f x)))) f) x))))

  ;; it seems to work...

  (lambda (f)
    (lambda (x)
      ((f (f (f x))))))

#+end_src
*** Exercise 2.7
#+begin_src scheme
  (define (lower-bound x) (car x))

  (define (upper-bound x) (cdr x))
#+end_src
*** Exercise 2.8
*Answer*:

Following Alyssa's way of reasoning, we should determine what's the
minimum value the subtraction could be, and let that value be the
lower bound (the first argument of ~make-interval~). And we should
determine what's the maximum value the subtraction could be, and let
that value be the upper bound (the second argument of
~make-interval~).

The minimum value the subtraction could be is the result of
subtracting the upper bound of y to the lower bound of x.

The maximum value the subtraction could be is the result of
subtracting the lower bound of y to the upper bound of x.

So:

#+begin_src scheme
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))
#+end_src
*** Exercise 2.9
*Exercise*:

#+begin_quote
The /width/ of an interval is half of the difference between its upper
and lower bounds. The width is a measure of the uncertainty of the
number specified by the interval. For some arithmetic operations the
width of the result of combining two intervals is a function only of
the widths of the argument intervals, whereas for others the width of
the combination is not a function of the widths of the argument
intervals. Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being
added (or subtracted). Give examples to show that this is not true for
multiplication or division.
#+end_quote

*Answer*:

Let's take the interval (make-interval 1 2) and the interval
(make-interval 3 4). The width of both is $\frac{1}{2}$. The sum of
the two intervals is an interval whose lower bound is 4 and whose
upper bound is 6. The width of the sum of the two interval is $(6-4)/2
= 1$.

Given this observation, we can hypothesize that the width of the sum
of two intervals is the sum of the widths of the two intervals being
added.

Let's make another observation to see whether it is compatible with
this hypothesis. Let's consider the interval (make-interval 3 6) and
the interval (make-interval 5 9). The width of the former is
$\frac{3}{2}$ and the width of the latter is $2$. The sum of the two
intervals is an interval whose lower bound is 8 and whose upper bound
is 15. The width of the sum of the two interval is $\frac{15 - 8}{2} =
\frac{7}{2}$. $\frac{7}{2}$ is the sum of $\frac{3}{2}$ and $2$. This
observation confirms the hypothesis that the width of the sum of two
intervals is the sum of the widths of the two intervals being added.

Let's try to somehow prove that it is generally the case that the
width of the sum of two intervals is the sum of the widths of the two
intervals being added.

##############sketchy###################
- The width of an interval is the the difference between upper bound
  and lower bound divided by 2.

- We can just focus on the difference, disregarding the division for
  simplicity.

- The sum of two interval a and b will have a difference which is the
  sum of the differences of the two intervals. (because...)

- But, if so, then the sum of the widths of a and b = the width of the
  sum.

- Therefore, the width of the sum is a function of the width of the
  two intervals.
########################################



Example of how this is not true for multiplication.

(make-interval 2 4) has a width of 1. (make-interval 3 5) has a width
of 1 too. Their multiplication gives an interval whose lower bound is
$6$ and whose upper bound is $20$. The width of the multiplication is
$20 - 6 = 7$.

If the width of the multiplication of two interval were a function of
only the widths of the interval being multiplied, then the width of
any other multiplication of two intervals whose widths are,
respectively, 1 and 1, must be 7.

We expect this hypothesis to be falsified.

To try to falsify it, let's consider the two intervals (make-interval
6 8) and (make-interval 10 12). The width of both is $1$. The
multiplication gives an interval whose lower bound is $60$ and whose
upper bound is 96. The width of the multiplication is $\frac{96 -
60}{2} = \frac{36}{2} = 18$.

We have computed the width of the multiplication of two intervals
whose width was respectively $1$ and $1$. The result was 7. We have
then computed the width of the multiplication of two different
intervals whose width was, again, respectively, 1 and 1. Therefore, we
can infer that the widht of the multiplication of two intervals is not
a function of only the widths of the two intervals being multiplied.

*** Exercise 2.10
*Exercise*:

#+begin_quote
Ben Bitdiddle, an expert systems programmer, looks over Alyssa’s
shoulder and comments that it is not clear what it means to divide by
an interval that spans zero. Modify Alyssa’s code to check for this
condition and to signal an error if it occurs.
#+end_quote

*Answer*:

#+begin_src scheme
  (define (div-interval x y)
    (if (= (lower-bound y) (upper-bound y))
        (display "error")
        (mul-interval x
                      (make-interval
                       (/ 1.0 (upper-bound y))
                       (/ 1.0 (lower-bound y))))))
#+end_src

*** Exercise 2.11
*Exercise*:

#+begin_quote
In passing, Ben also cryptically comments: “By testing the signs of
the endpoints of the intervals, it is possible to break mul-interval
into nine cases, only one of which requires more than two
multiplications.” Rewrite this procedure using Ben’s suggestion.

After debugging her program, Alyssa shows it to a potential user, who
complains that her program solves the wrong problem. He wants a
program that can deal with numbers represented as a center value and
an additive tolerance; for example, he wants to work with intervals
such as 3.5 ± 0.15 rather than [3.35, 3.65]. Alyssa returns to her
desk and fixes this problem by supplying an alternate constructor and
alternate selectors:

#+begin_src scheme
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+
        (lower-bound i)
        (upper-bound i))
       2))

  (define (width i)
    (/ (- (upper-bound i)
          (lower-bound i))
       2))
#+end_src

Unfortunately, most of Alyssa’s users are engineers. Real engineering
situations usually involve measurements with only a small uncertainty,
measured as the ratio of the width of the interval to the midpoint of
the interval. Engineers usually specify percentage tolerances on the
parameters of devices, as in the resistor specifications given
earlier.
#+end_quote

*Answer*:
** 2.2 Hierarchical Data and the Closure Property
~Cons~ is used to ``glue`` two things together into a /pair/. This
allows us to construct compound data.

We can represent a pair using the so-called /box-and-pointer
notation/, in which each object is represented as a /pointer/ to a box
(the box for a pair is actually a double box):

#+begin_src

*Figure 2.2:* Box-and-pointer representation of `(cons 1 2)'.

          +---+---+     +---+
     ---->| * | *-+---->| 2 |
          +-|-+---+     +---+
            |
            V
          +---+
          | 1 |
          +---+

[Figure from SICP Unofficial Texinfo Format version 2.neilvandyke4 (January 10, 2007)]
#+end_src

#+begin_quote
We have already seen that cons can be used to combine not only numbers
but pairs as well. [...] As a consequence, pairs provide a universal
building block from which we can construct all sorts of data
structures.
#+end_quote

The authors refer to the ability to create pairs whose elements are
pairs as the /closure property/ of cons, borrowing the term from
abstract algebra.

#+begin_quote
Closure is the key to power in any means of combination because it
permits us to create /hierarchical structures/ --- structures made up
of parts, which themselves are made up of parts, and so on.
#+end_quote
*** 2.2.1 Representing Sequences
There are many ways to represent a sequence (an ordered collection of
data objects) using pairs. Here is one:

#+begin_src scheme
  (cons 1
        (cons 2
              (cons 3
                    (cons 4 nil))))
#+end_src

A sequence of pairs, formed by nested ~conses~, like that above, is
called ~list~. Scheme provide the primitive ~list~ to create such
sequences.

#+begin_src scheme
  (list <a_1> <a_2> ... <a_n>)
#+end_src
is equivalent to
#+begin_src scheme
  (cons ⟨a_1⟩
        (cons ⟨a_2⟩
              (cons ...
                    (cons ⟨a_n⟩
                     nil)...)))
#+end_src

Do not confuse the expression ~(list 1 2 3 4)~ with the list ~(1 2 3
4)~...

~car~... ~cdr~... ~cadr~...

~nil~ can be thought of as a sequence with no elements, the ~empty
list~.

List operations (Two conventional programming techniques: ``cdring
down'' and ``consing up'').

~length~:

Recursively:
#+begin_src scheme
  (define (length items)
    (if (null? items)
        0
        (+ 1 (length (cdr items)))))
#+end_src

Iteratively:
#+begin_src scheme
  (define (length items)
    (define (length-iter a count)
      (if (null? a)
          count
          (length-iter (cdr a) (+ 1 count))))
    (length-iter items 0))
#+end_src


~list-ref~:

#+begin_src scheme
  (define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items)
                  (- n 1))))
#+end_src

~append~:

#+begin_src scheme
  (define (append list1 list2)
    (if (null? list1)
        list2
        (cons (car list1)
              (append (cdr list1)
                      list2))))
#+end_src
*** Exercise 2.17
Exercise:

#+begin_quote
Define a procedure last-pair that returns the list that contains only
the last element of a given (nonempty) list:
#+begin_src scheme
  (last-pair (list 23 72 149 34))
  (34)
#+end_src
#+end_quote

Answer:

#+begin_src scheme
  (define (last-pair l)
    (if (null? (cdr l))
        l
        (last-pair (cdr l))))
#+end_src
*** Exercise 2.18
Exercise:

#+begin_quote
Define a procedure `reverse' that takes a list as argument and returns
a list of the same elements in reverse order:

#+begin_src scheme
  (reverse (list 1 4 9 16 25))
  (25 16 9 4 1)
#+end_src
#+end_quote

Answer:

My intuitive solution was interative:
#+begin_src scheme
  (define (reverse l)
    (define (reverse-iter l result)
      (if (null? l)
          result
          (reverse-iter (cdr l) (cons (car l) result))))
    (reverse-iter l (list)))
#+end_src

After having solved the exercise iteratively, I've looked for a
recursive solution on the web and I found this one:
#+begin_src scheme
  (define (reverse l)
    (if (null? l)
        nil
        (append (reverse (cdr l))
                (list (car l)))))
#+end_src

*** TODO Exercise 2.19
*** Exercise 2.20
#+begin_src scheme
  ;; iterative solution (three slightly different versions):

  (define (same-parity1 i . rest)
    (define (condition i1 i2)
      (= (remainder i1 2)
         (remainder i2 2)))
    (define (same-party-inner i l result)
      (if (null? l)
          result
          (same-party-inner i
                            (cdr l)
                            (if (condition i (car l))
                                (cons (car l) result)
                                result))))
    (cons i (reverse (same-party-inner i rest (list)))))

  (define (same-parity2 i . rest)
    (define (condition i1 i2)
      (= (remainder i1 2)
         (remainder i2 2)))
    (define (same-party-inner i l result)
      (if (null? l)
          result
          (same-party-inner i
                            (cdr l)
                            (if (condition i (car l))
                                (cons (car l) result)
                                result))))
    (reverse (same-party-inner i rest (list i))))

  (define (same-parity3 i . rest)
    (define (condition i1 i2)
      (= (remainder i1 2)
         (remainder i2 2)))
    (define (same-party-inner i l result)
      (if (null? l)
          result
          (same-party-inner i
                            (cdr l)
                            (if (condition i (car l))
                                (append result (list (car l)))
                                result))))
    (same-party-inner i rest (list i)))

  (same-parity1 1 2 3 4 5 6 7) ;; (1 3 5 7)
  (same-parity2 1 2 3 4 5 6 7) ;; (1 3 5 7)
  (same-parity3 1 2 3 4 5 6 7) ;; (1 3 5 7)

#+end_src
*** Exercise 2.21
#+begin_src scheme
  (define (square-list items)
    (if (null? items)
        nil
        (cons (square (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map square items))
#+end_src
*** Exercise 2.22
``...defining square-list this way produces the answer list in the
reverse order of the one desired. Why?''

That procedures conses the square of first element of the list `items`
onto the empty list, obtaining foo0, the list that contains the square
of first element of the list `items`. Then, it conses the square of
the second element of the list `items` onto foo0, obtaining foo1, the
list that that contains the square of second element of the list
`items` and the square of first element of the list `items`, in that
order. Then it conses the square of the third element onto foo1,
obtaing foo2, the list that that contains the square of third element
of the list `items`, the square of second element of the list `items`
and the square of first element of the list `items`, in that
order. etc.

``This doesn’t work either. Explain.''

That procedures conses nil into the first element of `items`,
obtaining foo0, the pair whose first elemetn is nil and the second
element is the first element of `items. Then, it conses foo0 into the
second element of `items`, obtaining foo1, the pair whose first
element is foo0 and second element is the second element of
`items`. Then it conses foo1 onto the third element of `items`...

*** Exercise 2.23
#+begin_src scheme
  (define (for-each proc items)
    (if (null? items)
        true
        (and (proc (car items))
             (for-each proc (cdr items)))))
#+end_src
*** 2.2.2 Hierarchical Structures
#+begin_src scheme
  (define (count-leaves x)
    (con ((null? x) 0)
         ((not (pair? x)) 1)
         (+ (count-leaves (car x))
            (count-leaves (cdr x)))))
#+end_src
*** Exercise 2.24
see notebook
*** Exercise 2.25
#+begin_src emacs-lisp
  (setq x '(1 3 (5 7) 9))
  (car (cdr (car (cdr (cdr x))))) ;; => 7

  (setq x '((7)))
  (car (car x)) ;; => 7

  (setq x '(1 (2 (3 (4 (5 (6 7)))))))
  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr x)))))))))))) ;; => 7
#+end_src
*** Exercise 2.26
#+begin_src scheme
  ;; (append x y) => (1 2 3 4 5 6)
  ;; (cons x y)   => ((1 2 3) 4 5 6)
  ;; (list x y)   => ((1 2 3) (4 5 6))
#+end_src

*** Exercise 2.27
#+begin_src scheme
  (define (deep-reverse x)
    (define (iter x result)
      (cond ((null? x) result)
            ((not (pair? x)) x)
            (else (iter (cdr x)
                        (cons (iter (car x) nil) result))))) (iter x nil))
#+end_src

#+begin_src scheme
  ;; I've read The Little Schemer a while ago, in which a function atom?
  ;; like this one is defined:
  (define (atom? x)
    (and (not (pair? x)) (not (null? x))))

  (define (deep-reverse x)
    (define (iter x result)
      (cond ((atom? x) x)
            ((null? x) result)
            (else (iter (cdr x)
                        (cons (iter (car x) nil) result))))) (iter x nil))
#+end_src

#+begin_src emacs-lisp
  (defun iter (x result)
    (cond ((not (listp x)) x)
          ((null x) result)
          (t (iter (cdr x)
                   (cons (iter (car x) nil) result)))))
  (defun deep-reverse (x)
    (iter x nil))

  (deep-reverse '(1 2 3 (4 5)))
  ;; => ((5 4) 3 2 1)
#+end_src



Recursive-process-evolving version:
#+begin_src scheme
  ;; first attempt...
  ;; (define (deep-r t)
  ;;   (cond ((null? t) nil)
  ;;         ((pair? t) (append (deep-r (cdr t))
  ;;                            (deep-r (car t))))
  ;;         (else (list t))))

  (define (deep-reverse t)
    (cond ((null? t) nil)
          ((pair? t) (append (list (deep-reverse (cdr t)))
                             (list (deep-reverse (car t)))))
          (else (list t))))
#+end_src


*** Exercise 2.28
*Exercise*:

#+begin_quote
Write a procedure fringe that takes as argument a tree (represented as
a list) and returns a list whose elements are all the leaves of the
tree arranged in left-to-right order. For example,

#+begin_src scheme
  (define x
    (list (list 1 2) (list 3 4)))

  (fringe x)
  (1 2 3 4)

  (fringe (list x x))
  (1 2 3 4 1 2 3 4)
#+end_src
#+end_quote

*Answer*:

#+begin_src scheme
  (define (fringe x)
    (cond ((null? x) nil)
          ((not (pair? x)) (list x))
          (else (append (fringe (car x))
                        (fringe (cdr x))))))
#+end_src

#+begin_src scheme
  (define (fringe2 t)
    (cond ((null? t) nil)
          ((pair? t) (append (fringe2 (car t))
                             (fringe2 (cdr t))))
          (else (list t))))
#+end_src
*** Exercise 2.29
*Exercise*:

#+begin_quote
A binary mobile consists of two branches, a left branch and a right
branch. Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile. We can represent a binary
mobile using compound data by constructing it from two branches (for
example, using ~list~):

#+begin_src scheme
  (define (make-mobile left right)
    (list left right))
#+end_src

A branch is constructed from a ~length~ (which must be a number)
together with a ~structure~, which may be either a number (representing
a simple weight) or another mobile:

#+begin_src scheme
  (define (make-branch length structure)
    (list length structure))
#+end_src

1. Write the corresponding selectors ~left-branch~ and ~right-branch~,
   which return the branches of a mobile, and ~branch-length~ and
   ~branch-structure~, which return the components of a branch.
2. Using your selectors, define a procedure ~total-weight~ that returns
   the total weight of a mobile.
3. A mobile is said to be /balanced/ if the torque applied by its
   top-left branch is equal to that applied by its top-right branch
   (that is, if the length of the left rod multiplied by the weight
   hanging from that rod is equal to the corresponding product for the
   right side) and if each of the submobiles hanging off its branches
   is balanced. Design a predicate that tests whether a binary mobile
   is balanced.
4. Suppose we change the representation of mobiles so that the
   constructors are

   #+begin_src scheme
     (define (make-mobile left right)
       (cons left right))

     (define (make-branch length structure)
       (cons length structure))
   #+end_src

   How much do you need to change your programs to convert to the new
   representation?
#+end_quote

*Answer*:

1)

#+begin_src scheme
  (define (make-mobile left right)
    (list left right))

  (define (make-branch length structure)
    (list length structure))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (car (cdr mobile)))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (car (cdr branch)))

#+end_src

2)

- The total weight of a mobile is the total weight of the left branch
  plus the total weight of the left branch. (In this context,
  something is a branch if its car is a pair.)

- The total weight of branch whose branch structure is a mobile, is
  the the total weight of the mobile. (We can check whether a the
  branch structure of a mobile is a mobile by checking whether is a
  pair).

- The total weight of a branch whose branch structure is a weight, is
  the the weight.

With these three rules above we can write our function:
#+begin_src scheme
  (define (total-weight x)
    (cond ((pair? (car x)) (+ (total-weight (left-branch x))
                              (total-weight (right-branch x))))
          ((pair? (branch-structure x)) (total-weight (branch-structure x)))
          ((not (pair? (branch-structure x))) (branch-structure x))))
#+end_src

#+begin_src scheme
  (make-mobile (make-branch 1 2) (make-branch 3 4)) ;; => ((1 2) (3 4))
  (left-branch (make-mobile (make-branch 1 2) (make-branch 3 4))) ;; => (1 2)
  (right-branch (make-mobile (make-branch 1 2) (make-branch 3 4))) ;; => (3 4)
  (branch-structure (right-branch (make-mobile (make-branch 1 2) (make-branch 3 4)))) ;; => 4
  (total-weight (make-mobile (make-branch 1 2) (make-branch 3 4))) ;; => 6
  (total-weight (make-mobile (make-branch 1 2) (make-mobile (make-branch 1 2) (make-branch 3 4)))) ;; => 8
  (total-weight (make-mobile (make-mobile (make-branch 1 2) (make-branch 3 4)) (make-mobile (make-branch 1 2) (make-branch 3 4)))) ;; => 12
#+end_src

3)

#+begin_src scheme
  (define (torque branch)
    (* (branch-length branch)
       (total-weight branch)))

  (define (isBalanced mobile)
    (cond ((not (pair? (branch-structure (right-branch mobile))))
           (= (torque (left-branch mobile))
              (torque (right-branch mobile))))
          (else (and (= (torque (left-branch mobile))
                        (torque (right-branch mobile)))
                     (isBalanced (branch-structure (right-branch mobile)))))))

  (isBalanced (make-mobile (make-branch 2 2) (make-branch 2 2))) ;; => #t
  (isBalanced (make-mobile (make-branch 2 2) (make-branch 2 3))) ;; => #f

  (isBalanced (make-mobile (make-branch 2 2)
                           (make-branch 2 (make-mobile (make-branch 1 1)
                                           (make-branch 1 1 ))))) ;; => #t
  (isBalanced (make-mobile (make-branch 2 2)
                           (make-branch 2 (make-mobile (make-branch 2 1)
                                                       (make-branch 1 1 ))))) ;; => #f
#+end_src

4)

If we changed the representation of mobiles so to have
#+begin_src scheme
  (define (make-mobile left right)
    (cons left right))

  (define (make-branch length structure)
    (cons length structure))
#+end_src
then, we would only need to change the selectors ~right-branch~ and
~branch-structure~:
#+begin_src scheme
  (define (right-branch mobile)
    (cdr mobile))

  (define (branch-structure branch)
    (cdr branch))
#+end_src

Both ~left-branch~ and ~branch-length~ would still work, and neither
~total-weight~ nor ~isBalanced~ depend on the details of how mobiles
and branchs are constructed.

*** Exercise 2.30
#+begin_quote
Define a procedure square-tree analogous to the square-list procedure
of Exercise 2.21. That is, square-tree should behave as follows:

#+begin_src scheme
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
  (1 (4 (9 16) 25) (36 49))
#+end_src

Define square-tree both directly (i.e., without using any higher-order
procedures) and also by using map and recursion.
#+end_quote

#+begin_src scheme
  (define (square x) (* x x))

  (define (square-tree tree)
    (cond ((null? tree) nil)
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))

  (define (square-tree tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (square-tree sub-tree)
               (square sub-tree)))
         tree))
#+end_src

*** Exercise 2.31
``Directly'':
#+begin_src scheme
  (define (tree-map proc tree)
    (cond ((null? tree) nil)
          ((not (pair? tree)) (proc tree))
          (else (cons (tree-map proc (car tree))
                      (tree-map proc (cdr tree))))))

                      #+end_src

Using map:
#+begin_src scheme
  (define (tree-map proc tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (tree-map proc sub-tree)
               (proc sub-tree)))
         tree))
#+end_src

*** Exercise 2.32
The first guess was correct:
#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list nil)
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x)
                              (cons (car s) x))
                            rest)))))
#+end_src

Let's have a look at the evolution of the process evolved by subsets
(as a tree):
#+begin_src
                                           (subsets (list 1 2 3))
                                                   |
                                                 append
                                      ____________/ \____________
                                     /                           \
                              (subsets '(2 3))                map consing 1
                                    |                             |
                                  append                  (subsets '(2 3))
                       ____________/ \____________                |
                      /                           \              ...
              (subsets '(3))                 map consing 2
       ____________/ \____________                |
      /                           \         (subsets '(3))
(subsets '())             map consing 3           |
      |                           |              ...
   '(nil)                  (subsets '())
                                  |
                               '(nil)
#+end_src

We can see that for each list with one element /a/, ~subsets~ will
return, correctly, a list /l1/ whose members are the empty list and
/a/:
#+begin_src
(a) => ( () (a) )
#+end_src

What if we add one element /b/ to the list with /a/? The right answer
must be the list whose memembers are the members in /l1/ plus each
member of /l1/ with /b/ in it:
#+begin_src
(a b) => ( () (a) (b) (a b))
#+end_src
This is exactly what ~subsets~ does: it returns the list (created by
appending) all members of /l1/ and each each member of /l1/ with b in
it (that is, the result of applying ~append~ to /l1/ and the map of
/l1/ in which we cons ~b~ in each element of /l1/).

What if we add one element /c/ to the list with /a/ and /b/?
Analogously...

*** 2.2.3 Sequences as Conventional Interfaces
- Data abstraction permits us to:
  - design programs without dealing with details of data
    representation,
  - experiment with alternative representations.

- Here another powerful design principle fro working with data
  strcutures is introduced: /conventional interfaces/.

Consider the following two procedures. The first one computes the sum
of the squares of the odd leaves of a tree. The second one constructs
a list of all the even Fibonacci numbers up to ~n~.

#+begin_src scheme
  (define (sum-odd-squares tree)
    (cond ((null? tree) 0)
          ((not (pair? tree))
           (if (odd? tree) (square tree) 0))
          (else (+ (sum-odd-squares
                    (car tree))
                   (sum-odd-squares
                    (cdr tree))))))
#+end_src

#+begin_src scheme
  (define (even-fibs n)
    (define (next k)
      (if (> k n)
          nil
          (let ((f (fib k)))
            (if (even? f)
                (cons f (next (+ k 1)))
                (next (+ k 1))))))
    (next 0))
#+end_src

Those two functions don't look very similar. However, at a certain
level of abstraction, they are:

The first procedure:
- *enumerates* the leaves of a tree;
- *filters* them, selecting the odd ones;
- *squares* each of the selected ones; and
- *accumulates* the result using +, starting with 0.

The second procedure:
- *enumerates* the integers from 0 to n;
- *computes* the Fibonacci number for each integer;
- *filters* them, selecting the even ones; and
- *accumulates* the result using ~cons~, starting with the empty list.

These processes can be described in terms of ``signals flowing through
a cascade of stages''.

#+begin_src
  +-------------+   +-------------+   +-------------+   +-------------+
  | enumerate:  |-->| filter:     |-->| map:        |-->| accumulate: |
  | tree leaves |   | odd?        |   | square      |   | +, 0        |
  +-------------+   +-------------+   +-------------+   +-------------+

  +-------------+   +-------------+   +-------------+   +-------------+
  | enumerate:  |-->| map:        |-->| filter:     |-->| accumulate: |
  | integers    |   | fib         |   | even?       |   | cons, ()    |
  +-------------+   +-------------+   +-------------+   +-------------+
#+end_src

However, our two procedures fail to exhbit the signal-flow structure
just described. If they did show such a structure, then we would
achieve greater conceptual clarity.

{...}

#+begin_src scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))
#+end_src

# (define our-list '(1 2 3))
# (op 1 (op 2 (op 3 initial))))
# (accumulate + 0 our-list)
# (+ 1 (+ 2 (+ 3 0))))
# (cons (p 1) (cons (p 2) (cons (p 3) nil))))

*** Exercise 2.33
*Exercise*:

Fill in the missing expressions to complete the following definitions
of some basic list-manipulation operations as accumulations:

*Answer*:

To warmup, here is how you can use accumulate to return the list
itself:
#+begin_src scheme
  (define (list-identity sequence)
    (accumulate (lambda (x y) (cons x y)) nil sequence))
#+end_src

Given ~list-identity~, it's easy to write ~map~:
#+begin_src scheme
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
#+end_src

Append:
#+begin_src scheme
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
#+end_src

Length:
#+begin_src scheme
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+end_src

*** TODO Exercise 2.34
I don't know what it means to evaluate a polynomial in x at a given
value of x...

#+begin_src scheme

#+end_src
*** Exercise 2.35
#+begin_src scheme
  (define (count-leaves t)
    (accumulate <??>
                <??>
                (map <??> <??>)))
#+end_src

Hacky (cheating?) solution: just rename the old ~count-leaves~ as
~count-leaves1~ and:
#+begin_src scheme
  (define (count-leaves t)
    (accumulate +
                0
                (map count-leaves1
                     t)))
#+end_src

The following solution uses ~map~ to ~fringe~ each member of ~t~ which
is a pair, producing a list of atoms and one-level-lists; then it uses
the accumulate to sum each member treated as a 1 if it's an atom or as
the length of itself if it's a list.
#+begin_src scheme
  (define (map proc items)
    (if (null? items)
        nil
        (cons (proc (car items))
              (map proc (cdr items)))))

  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op
                        initial
                        (cdr sequence)))))

  (define (append list1 list2)
    (if (null? list1)
        list2
        (cons (car list1)
              (append (cdr list1)
                      list2))))
  (define (fringe x)
    (cond ((null? x) nil)
          ((not (pair? x)) (list x))
          (else (append (fringe (car x))
                        (fringe (cdr x))))))

  (define (length l)
    (if (null? l)
        0
        (+ 1 (length (cdr l)))))

  (define (gp-length l)
    (if (not (pair? l))
        1
        (length l)))

  (define (gp-count-leaves t)
    (accumulate (lambda (a b)
                  (+ (gp-length a)
                     b))
                0
                (map fringe t)))

  (gp-count-leaves '(1 (2) (((3 4 5)) 4)))
#+end_src

This above was my solution. I've been told another, better, solution:
#+begin_src scheme
  (define (dean-count-leaves t)
    (accumulate +
                0
                (map
                 (lambda (x) (if (pair? x)
                                 (dean-count-leaves x)
                                 1)) t)))
#+end_src
*** 2.36
#+begin_src scheme
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        nil
        (cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+end_src
*** 2.38
#+begin_src scheme
  (define (fold-right op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (fold-right op initial (cdr sequence)))))

  (fold-right / 1 (list 1 2 3))
  ;; (/ 1 (/ 2 (/ 3 1)))

  (fold-right list nil (list 1 2 3))
  ;; (list 1 (list 2 (list 3 nil)))

  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))

  (fold-left / 1 (list 1 2 3))
  (/ (/ (/ 1 1) 2) 3)

  (fold-left list nil (list 1 2 3))
  ;; (list (list (list nil 1) 2) 3)
#+end_src
*** 2.39
#+begin_src scheme
  (define (reverse seq)
    (fold-right (lambda (x y) (append y (list x)))
                nil
                seq))

  (define (reverse seq)
    (fold-left (lambda (x y) (append (list y) x))
               nil
               seq))
#+end_src
*** 2.40
#+begin_src scheme
  (define (unique-pairs n)
    (flatmap
     (lambda (i)
       (map (lambda (j)
              (list i j))
            (enumerate-interval
             1
             (- i 1))))
     (enumerate-interval 1 n)))

  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter
          prime-sum?
          (unique-pairs n))))
#+end_src
*** 2.41
Excercise:

#+begin_quote
Write a procedure to find all ordered triples of distinct positive
integers /i/, /j/, and /k/ less than or equal to a given integer /n/
that sum to a given integer /s/.
#+end_quote

Answer:

- We can:
  - enumerate all ordered triples (see below how);
  - filter them;

- In order to enumerate all triples:
  - for each element /e/, enumerate all the possible pairs from 1 to
    /n/ without using /e/, and then adjoin /e/ to the front of each
    pair.

- In order to enumerate all possible pairs from 1 to /n/:
  - for each element /e/ of the range from 1 to /n/, enumerate all
    other elements of the range, and for each of those other elements
    create the list ~(e other-element)~.

#+begin_src scheme
  (define (accumulate op initial seq)
    (if (null? seq)
        initial
        (op (car seq)
            (accumulate op initial (cdr seq)))))

  (define (filter predicate seq)
    (cond ((null? seq) nil)
          ((predicate (car seq))
           (cons (car seq) (filter predicate (cdr seq))))
          (else (filter predicate (cdr seq)))))

  (define (enumerate-interval low high)
    (if (> low high)
        nil
        (cons low
              (enumerate-interval
               (+ low 1)
               high))))

  (define (enumerate-interval-except low high not-allowed)
    (filter (lambda (x) (not (= x not-allowed)))
            (enumerate-interval low high)))

  ;; create a list of all possible pairs given a sequence
  (define (all-pairs seq)
    (accumulate
     append
     nil
     (map (lambda (x)
            (map (lambda (y)
                   (cons x (list y)))
                 (filter (lambda (e) (not (= e x))) seq)))
          seq)))

  ;; all triples from 1 to n
  (define (all-triples n)
    (accumulate
     append
     nil
     (map (lambda (x)
            (map (lambda (y) (cons x y))
                 (all-pairs (enumerate-interval-except 1 n x))))
          (enumerate-interval 1 n))))

  (define (all-triples-sum n sum)
    (filter (lambda (x)
              (= (+ (car x)
                    (car (cdr x))
                    (car (cdr (cdr x))))
                 sum))
            (all-triples n)))

  (all-triples-sum 56 8)
  ;; => ((1 2 5) (1 3 4) (1 4 3) (1 5 2) (2 1 5) (2 5 1) (3 1 4) (3 4 1) (4 1 3) (4 3 1) (5 1 2) (5 2 1))
#+end_src
*** 2.42
#+begin_src scheme
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions)
             (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position
                      new-row
                      k
                      rest-of-queens))
                   (enumerate-interval
                    1
                    board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))
#+end_src
#+begin_src scheme
  (define (filter pred seq)
    (cond ((null? seq) nil)
          ((pred (car seq)) (cons (car seq) (filter pred (cdr seq))))
          (else (filter pred (cdr seq)))))

  (define (accumulate op initial seq)
    (if (null? seq)
        initial
        (op (car seq)
            (accumulate op initial (cdr seq)))))

  (define (flatmap op seq)
    (accumulate append nil (map op seq)))

  (define (enumerate-interval low high)
    (if (> low high)
        nil
        (cons low (enumerate-interval (+ low 1) high))))

  (define (safe? k poss)
    (let ((queen (car (filter
                       (lambda (q)
                         (= (car (cdr q)) k))
                       poss))))
      (if (> (length
              (filter
               (lambda (p)
                 (or (= (car queen)
                        (car p))
                     (= (- (car p) (car queen))
                        (- (car (cdr p)) (car (cdr queen))))
                     (= (- (car p) (car queen))
                        (- (car (cdr queen)) (car (cdr p))))))
               poss))
             1)
          #f
          #t)))

  (define (adjoin-position nr k rq)
    (cons (list nr k) rq))

  (define empty-board nil)

  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions) (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))
#+end_src
*** 2.2.4 Example: A Picture Language
- ``...a simple language for drawing pictures that illustrates the
  power of data abstraction and closure, and also exploits
  higher-order procedures in an essential way.''


- ``In this language, the data objects being combined are represented
  as procedures rather than as list structure.''

- the operations in this language satisfy the closure property. We are
  therefore capable to ``build arbitrarily complicated patterns''.

- ``When we began our study of programming in 1.1, we emphasized the
  importance of describing a language by focusing on the language’s
  primitives, its means of combination, and its means of
  abstraction. We’ll follow that framework here.''

- In this picture language there is only one kind of element: the
  /painter/. A painter draws an image that is shifted and scaled to
  fit withtin a designated parallelogram-shpaed frame.
  - Painter ~wave~.
  - Painter ~rogers~.

- Operations that construct painters from painters.
  - ~beside~.
  - ~below~.
  - ~flip-vert~
  - ~flip-horiz~

- Defining ~wave4~.

- ``In building up a complex image in this manner we are exploiting
  the fact that painters are closed under the language’s means of
  combination.''

- Defining ~wave4~ in terms of ~flipped-pairs~.

- Defining recursive operations
  - ~right-split~.
  - ~corner-split~.

- Defining ~square-limit~.

- Abstracting patterns of combining painter operations.
  - ~square-of-four~.
  - Defining ~flipper-pairs~ in terms of ~square-of-four~.
  - Defining ~square-limit~ in terms of ~square-of-four~.

- A frame can be described by three vectors.

- ~frame-coord-map~.

- ``A painter is represented as a procedure that, given a frame as
  argument, draws a particular image shifted and scaled to fit the
  frame. That is to say, if ~p~ is a painter and ~f~ is a frame, then
  we produce ~p~ ’s image in ~f~ by calling p with ~f~ as argument.''

  #+begin_src scheme
    (define (segments->painter segment-list)
      (lambda (frame)
        (for-each
         (lambda (segment)
           (draw-line
            ((frame-coord-map frame)
             (start-segment segment))
            ((frame-coord-map frame)
             (end-segment segment))))
         segment-list)))
  #+end_src

# (paint (segments->painter (list (make-segment
#                            (make-vect 0.2 0.5)
#                            (make-vect 0.5 0.1)))))


*** Ex. 2.44
*Exercise*:

#+begin_quote
Define the procedure ~up-split~ used by ~corner-split~. It is similar
to ~right-split~, except that it switches the roles of below and
beside.
#+end_quote

*Answer*:

#+begin_src scheme
  (define (up-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (right-split painter (- n 1))))
          (below painter (beside smaller smaller)))))
#+end_src
*** Ex. 2.45
*Exercise*:

#+begin_quote
~Right-split~ and ~up-split~ can be expressed as instances of a
general splitting operation. Define a procedure ~split~ with the
property that evaluating

#+begin_src scheme
  (define right-split (split beside below))
  (define up-split (split below beside))
#+end_src

produces procedures ~right-split~ and ~up-split~ with the same
behaviors as the ones already defined.
#+end_quote

*Answer*:

#+begin_src scheme
  (define (split p1 p2)
    (lambda (painter n)
      (if (= n 0)
          painter
          (let ((smaller ((split p1 p2) painter
                          (- n 1))))
            (p1 painter
                (p2 smaller smaller))))))
#+end_src
*** Ex. 2.46
*Answer*:

#+begin_src scheme
  (define (make-vect xcor ycor)
    (cons xcor ycor))
  ;; alternatively:
  ;; (define make-vect cons)

  (define (xcor-vect vect)
    (car vect))
  ;; alternatively:
  ;; (define xcor-vect car)

  (define (ycor-vect vect)
    (cdr vect))
  ;; alternatively
  ;; (define ycor-vect cdr)

  (define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v1))))

  (define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))

  (define (scale-vect vect s)
    (make-vect (* (xcor-vect vect) s)
               (* (ycor-vect vect) s)))
#+end_src

*** Ex. 2.47
*Answer*:

#+begin_src scheme
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (car (cdr frame)))

  (define (edge2-frame frame)
    (car (cdr (cdr frame))))
#+end_src


#+begin_src scheme
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (car (cdr frame)))

  (define (edge2-frame frame)
    (cdr (cdr frame)))
#+end_src

*** 2.48
*Exercise*:

#+begin_quote
A directed line segment in the plane can be represented as a pair of
vectors---the vector running from the origin to the start-point of the
segment, and the vector running from the origin to the end-point of
the segment. Use your vector representation from Exercise 2.46 to
define a representation for segments with a constructor ~make-segment~
and selectors ~start-segment~ and ~end-segment~.
#+end_quote

*Answer*:

#+begin_src scheme
  (define (make-segment vector1 vector2)
    (cons vector1 vector2))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))
#+end_src

*** 2.49
#+begin_src scheme
  ;; Painter that draws the outline of the frame
  (segments->painter
   (list
    (make-segment (make-vect 0 0)
                  (make-vect 0 1))
    (make-segment (make-vect 0 1)
                  (make-vect 1 1))
    (make-segment (make-vect 1 1)
                  (make-vect 1 0))
    (make-segment (make-vect 1 0)
                  (make-vect 0 0))))
#+end_src

#+begin_src scheme
  ;; Painter that draws an ``X''
  (segments->painter
   (list
    (make-segment (make-vect 0 0)
                  (make-vect 1 1))
    (make-segment (make-vect 1 0)
                  (make-vect 0 1))))
#+end_src

#+begin_src scheme
  ;; Painter that draws a diamond
  (segments->painter
        (list
         (make-segment (make-vect 0.5 0)
                       (make-vect 0 0.5))
         (make-segment (make-vect 0 0.5)
                       (make-vect 0.5 1))
         (make-segment (make-vect 0.5 1)
                       (make-vect 1 0.5))
         (make-segment (make-vect 1 0.5)
                       (make-vect 0.5 0))))
#+end_src

*** Ex. 2.50
#+begin_src scheme
  (define (flip-horiz painter)
    (transform-painter
     painter
     (make-vect 1.0 0.0)
     (make-vect 0.0 0.0)
     (make-vect 1.0 1.0)))
#+end_src

#+begin_src scheme
  (define (rotate-cc-180 painter)
    (transform-painter
     painter
     (make-vect 1.0 1.0)
     (make-vect 0.0 1.0)
     (make-vect 1.0 0.0)))
#+end_src

#+begin_src scheme
  (define (rotate-cc-270 painter)
    (transform-painter
     painter
     (make-vect 0.0 1.0)
     (make-vect 0.0 0.0)
     (make-vect 1.0 1.0)))
#+end_src

*** Ex. 2.51
#+begin_src scheme
  (define (below2 p1 p2)
    (let ((paint-below (transform-painter
                        p1
                        (make-vect 0.0 0.0)
                        (make-vect 1.0 0.0)
                        (make-vect 0.0 0.5)))
          (paint-above (transform-painter
                        p2
                        (make-vect 0.0 0.5)
                        (make-vect 1.0 0.5)
                        (make-vect 0.0 1.0))))
      (lambda (frame)
        (paint-below frame)
        (paint-above frame))))

  (paint (below2 einstein einstein))
#+end_src

#+begin_src scheme
  (define (rotate-counterclock-90 painter)
    (transform-painter
     painter
     (make-vect 1.0 0.0)
     (make-vect 1.0 1.0)
     (make-vect 0.0 0.0)))

  (define (rotate-clock-90 painter)
    (transform-painter
     painter
     (make-vect 0.0 1.0)
     (make-vect 0.0 0.0)
     (make-vect 1.0 1.0)))

  (define (below3 p1 p2)
    (rotate-clock-90 (beside (rotate-counterclock-90 p1)
                             (rotate-counterclock-90 p2))))

  (paint (below3 einstein einstein))
#+end_src

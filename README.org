#+title: Structure and Interpretation of Computer Programs
#+subtitle: Personal notes
#+options: num:nil


Memorably, computer science --- the subject matter of the book --- is
presented as a non-science whose signficance has little to do with
computers (see also the [[https://youtu.be/-J_xL4IGhJA?list=PLE18841CABEA24090&t=26][lecture]]). Just as memorably, computer science
is presented as a branch of /epistemology/, that is, the study of
/knowledge/ (which, tipically, is considered part of /philosophy/). In
particular, computer science is /procedural/ epistemology. We deal
here with the systematization of imperative, /how-to/, knowledge, as
opposed to ``declarative'' knowledge. The computer scientist deals,
indeed, with a complexity that resembles that of the human mind ---
notice the epigraph from Locke. Much of his job is dominating the
``intellectual complexity'' of software systems.

Here is a bullet-point summary up to section 1.1 (included) and my
solutions of the exercises. As expected these first pages present
fundamental concepts and building blocks.

* Foreword (by Alan J. Perlis)
- The subject matter of this book involves three foci of phenomena
  - the human mind;
  - collection of computer programs;
  - the computer.

- /Idioms/: ``standard program structures of whose corrected we have
  becamse sure''.

- /Algorithms/: programs that ``perform a precise mathematical
  function such as sorting or finding the maximum of a sequence of
  numbers , determining primality, or finding the square root.''

#+begin_quote
A programmer should acquire good algorithms and idioms. (xiii)
#+end_quote

* Preface to the First Edition
- The authors express two major concerns:
  1. They want to establish the idea ``idea that a computer language
     is not just a way of getting a computer to perform operations but
     rather that it is /a novel formal medium for expressing ideas
     about methodology/'' (my emphasis).

  2. The essential material of interest here are the /techniques used
     to/ /control the intellectual complexity of large software
     systems/; not: matters of syntax of particular languages, clever
     algorithms in special contexts, mathematical analysis of
     algorithms, or foundations of computing.

- Computer science is not science and its significance has very little
  to do with computers.

- /Procedural Epistemology/: ``the study of the structure of knowledge
  from an imperative point of view, as opposed to a more declarative
  point of view...''.

* 1. Building Abstractions with Procedures
- A /Computational process/ is an abstract thing that inhabits a computer.

- /Data/ are other abstract things manipulated by processes.

- A /program/ is a pattern of rules that direct the evolution of a process.

- Programs are composed from expressions in /programming languages/.

- Good design is /modular/.

- Lisp /interpreter/: ``a machine that carries out processes described
  in the Lisp language''.

- ``...Lisp descriptions of processes, called /procedures/, can
  themselves be represented and manipulated as Lisp data. The
  importance of this is that there are powerful program-design
  techniques that rely on the ability to blur the traditional
  distinction between ``passive'' data and ``active'' processes.''

** The elements of programming
- A powerful programming language enables us to describe processes and
  organize our ideas about them, not merely to instruct a computer to
  perform some operations.

- To organize our ideas about processes well we must be able to
  combine simple ideas to give life to more complex ones. We can do so
  through three mechanisms provided by a powerful programming
  language:
  - *Primitive expressions*
  - *Means of combinations*
  - *Means of abstractions*

*** Expressions
- ``You type an /expression/, and the interpreter responds by
  displaying the result of its /evaluating/ that expression.''

- /Combinations/;
- /Operator/;
- /Operands/;
- /Arguments/.

- /read-eval-print loop/: ``the intepreter always operates in the same
  basic cycle: It reads an expression from the terminal, evaluates the
  expression, and prints the result''.

*** Naming and the Environment
- A programming language provides means to use names to refer to
  computational object. ``We say that the name identifies a /variable/
  whose /value/ is the object.''

- `` ~Define~ is our language's simples means of abstraction.

- /Environment/.

*** Evaluating Combinations
- The interpreter evaluates combinations by following a procedure:
  #+begin_quote
  - To evaluate a combination, do the following:
    1. Evaluate the subexpressions of the combination;
    2. Apply the procedure that is the value of the leftmost
       subexpression (the operator) to the arguments that are the values
       of the other subexpressions (the operands).
  #+end_quote

- The evaluation rule is /recursive/.

- We can view the evaluation in terms of a tree (See p. 10).
  
  [[./figure1-1.gif]]

- Tree accumulation.

- /Special forms/ constitute exceptions to the general evaluation
  rule. ~Define~ is a special form.

*** Compound Procedures
- /Procedure definitions/: a much more powerful abstraction technique.

- /Compound procedures/.

*** The Substitution Model for Procedure Application
- Application process for compound procedures:
  - To apply a compound procedure to arguments, evaluate the body of
    the procedure with each formal parameter replaced by the
    corresponding argument.

- /Substitution model/ for procedure application: a model to determine
  the ``meaning'' of procedure application (in this chapter);
  - This is not how interpreters actually work;
  - The substitution model is the first of a sequence of increasingly
    elaborated models presented in this book of how intepreters
    work. Chapter 5 will present a complete implemetation of an
    interpreter an compiler.

- Lisp uses /applicative-order/ evaluation: the interpreter evaluates
  the operator and the operands and then applies the resulting
  procedure to the resulting arguments --- the procedure (followed by
  the intepreter to evaluate a combination) described above.

- An alternative evaluation mode: /normal-order/ evaluation.

*** Conditional Expressions and Predicates
- ~cond~
- ~if~
- ~and~
- ~or~
- ~not~
*** Exercise 1.1
Exercise:
#+begin_quote
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence
is to be evaluated in the order in which it is presented.

#+begin_src scheme
  10
  (+ 5 3 4)
  (- 9 1)
  (/ 6 2)
  (+ (* 2 4) (- 4 6))
  (define a 3)
  (define b (+ a 1))
  (+ a b (* a b))
  (= a b)
  (if (and (> b a) (< b (* a b)))
      b
      a)
  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  (+ 2 (if (> b a) b a))
  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
#+end_src
#+end_quote

Answer:
#+begin_src elisp
  10
  ;; 10

  (+ 5 3 4)
  ;; 12

  (- 9 1)
  ;; 8

  (/ 6 2)
  ;; 3

  (+ (* 2 4) (- 4 6))
  ;; 6
#+end_src

The authors, p. 8 fn. 8, say that the response to evaluating
definitions is ``highly implementation-dependent''.

I gather that Scheme's ~define~, when used for variables, is
equivalent for Elisp's ~setq~.

#+begin_src elisp
  (setq a 3)
  ;; 3

  (setq b (+ a 1))
  ;; 4

  (+ a b (* a b))
  ;; 19
#+end_src

I gather that Scheme's ~=~, when used for variables, is
equivalent for Elisp's ~eq~.

#+begin_src elisp
  (eq a b)
  ;; nil

  (if (and (> b a) (< b (* a b)))
      b
    a)
  ;; 4

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  ;; 16

  (+ 2 (if (> b a) b a))
  ;; 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
  ;; 16
#+end_src
*** Exercise 1.2
Exercise:
#+begin_quote
Translate the following expression into prefix form

$\frac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3(6 - 2)(2 - 7)}$
#+end_quote

Answer: 
#+begin_src elisp
  (/ (+ 5 
        4 
        (- 2
           (- 3
              (+ 6
                 (/ 4 5))))) 
     (* 3 
        (- 6 2) 
        (- 2 7))) 
#+end_src
*** Exercise 1.3
Exercise:
#+begin_quote
Define a procedure that takes three numbers as arguments and returns
the sum of the squares of the two larger numbers.
#+end_quote

Answer:

This was my first solution:
#+begin_src emacs-lisp
  (defun foo (a b c)
    (+ (square (if (> a b) a b))
       (square (if (> c
                      (if (> a b) b a))
                   c
                 (if (> a b) b a)))))
#+end_src

That works, although it is not ideal, because the combination ~(> a
b)~ is evaluated three times...
*** Exercise 1.4
Exercise:
#+begin_quote
Observe that our model of evaluation allows for combinations whose
operators are compound expressions. Use this observation to describe
the behavior of the following procedure:

#+begin_src scheme
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+end_src
#+end_quote

Answer:

Behavior: If ~b~ is greater than 0, then apply ~+~ to ~a~ and ~b~,
that is, add ~b~ to ~a~. Otherwise, apply ~-~ to ~a~ and ~b~, that is,
to subtract ~b~ from ~a~.

But subtracting a negative number, means adding it!  So, behavior: Add
the absolute value of ~b~ to ~a~.
*** Exercise 1.5
Exercise:

#+begin_quote
Ben Bitdiddle has invented a test to determine whether the interpreter
he is faced with is using applicative-order evaluation or normal-order
evaluation. He defines the following two procedures:

#+begin_src scheme
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
        0
        y))
#+end_src

Then he evaluates the expression

#+begin_src scheme
  (test 0 (p))
#+end_src

What behavior will Ben observe with an interpreter that uses
applicative-order evaluation? What behavior will he observe with an
interpreter that uses normal-order evaluation? Explain your
answer. (Assume that the evaluation rule for the special form if is
the same whether the interpreter is using normal or applicative order:
The predicate expression is evaluated first, and the result determines
whether to evaluate the consequent or the alternative expression.)
#+end_quote

Answer:

In the case of applicative-order evaluation, ``the interpreter first
evaluates the operator and operands and then applies the resulting
procedure to the resulting arguments'' (p. 16). This means that the
interpreter will evaluate ~test~, then ~0~ and then ~(p)~. ~test~
evaluates to a procedure. ~0~ evaluates to ~0~. But ~(p)~ evaluates to
~(p)~, which evaluates to ~(p)~, which evaluates to (p)', which... /ad
infinitum/. So, the interpreter enters an infinite evaluation; it will
never be able to apply the procedure denoted by ~test~, because it
will never be able to compute the second argument.

In the case of normal-order evaluation, operands are not evaluated
until their values are needed. ~(test 0 (p))~ would be turned into ~0~
and then evaluated. And '0' evaluates to 0.
*** 1.1.7 Example: Square Roots by Newton’s Method
- Procedures are analogous to mathematical functions: ``[t]hey specify a
  value that is determined by one or more parameters''. (21-22)

- However, procedures are different from mathematical functions in
  some respects. A mathematical function can tell us, say, whether a
  certain number is the square root of ~x~ or not. That, however, does
  not describe a /procedure/. It does not tell us /how to find/ the
  square root of ~x~.

- More generally, mathematics is usually concerned with ``declarative
  knowledge'', whereas computer science is concerned with ``imperative
  knowledge''.  

- Iteration can be accomplished by calling a procedure. We don't need
  any looping construct.  
*** Exercise 1.6
Exercise: 

#+begin_quote
Alyssa P. Hacker doesn't see why ~if~ needs to be provided as a
special form. ``Why can't I just define it as an ordinary procedure in
terms of ~cond~?'' she asks. Alyssa's friend Eva Lu Ator claims this
can indeed be done, and she defines a new version of ~if~:

#+begin_src scheme
  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))
#+end_src

Eva demonstrates the program for Alyssa:

#+begin_src scheme
  (new-if (= 2 3) 0 5)
  5
#+end_src

#+begin_src scheme
  (new-if (= 1 1) 0 5)
  0
#+end_src

Delighted, Alyssa uses ~new-if~ to rewrite the square-root program:

#+begin_src scheme
  (define (sqrt-iter guess x)
    (new-if (good-enough? guess x)
            guess
            (sqrt-iter (improve guess x)
                       x)))
#+end_src

What happens when Alyssa attempts to use this to compute square roots? Explain.
#+end_quote

Answer:

~cond~ is a /special form/. ~if~, too, is a special form. ~new-if~,
instead, is not a special form. It is an ordinary /combination/.

Now, the evaluation of a combination entails the evaluation of both
the /operator/ and the /operands/. With Eva's ~new-if~, then,
~sqrt-iter~ calls itself /ad infinitum/ and a stack overflow occurs.

In fact, if we replace the ~new-if~ --- a combination --- with the
~cond~ --- a special form --- it would evaluate to, then things will
work as originally intended.
*** Exercise 1.7
#+begin_quote
The ~good-enough?~ test used in computing square roots will not be
very effective for finding the square roots of very small
numbers. Also, in real computers, arithmetic operations are almost
always performed with limited precision. This makes our test
inadequate for very large numbers. Explain these statements, with
examples showing how the test fails for small and large numbers. An
alternative strategy for implementing ~good-enough?~ is to watch how
guess changes from one iteration to the next and to stop when the
change is a very small fraction of the guess. Design a square-root
procedure that uses this kind of end test. Does this work better for
small and large numbers?
#+end_quote

Answer: 

This is a pretty small number: $0.00025$. It's square root is
$\sqrt{0.00025} = 0.0158113883$ (I have used a calculator).

Let's try to apply our test to the right answer divided by two.
#+begin_src emacs lisp
  (good-enough? (/ 0.0158113883 2) 0.00025)
#+end_src
The test returns true; that is, it's telling us that half of the right
answer is good enough. I take that as a failure.

When we are dealing with very small numbers, then the $0.001$ used in
our test is too big for our purposes.

This is a pretty big number: $7894561230.0123456789$. The square root
of this number is $\sqrt{7894561230.0123456789} = 88851.3434339$ (I
have used a calculator).

Let's see whether are test consider the right answer as good
enough...

#+begin_src emacs-lisp
  (good-enough? 88851.3434339 7894561230.0)
#+end_src

This evaluate to ~nil~...  The problem seems to lie in the application
of (the procedure named by) ~square~, which gives a rather imprecise
result.

This is the body of ~good-enough?~:
#+begin_src emacs-lisp
  (< (abs (- (square 88851.3434339) 7894561230.0)) 0.001)
#+end_src
It evaluates to ~nil~, because the difference between the square of
the guess and the radicant is greater than 0.001. However, the
/actual/ square of the radicant does not differ from the radicant of a
value greater than 0.001.


Here is my version of an improved version of ~good-enough?~ following
the authors' suggestion:

#+begin_src emacs-lisp
  (defun good-enough-improved? (new-guess old-guess)
    (< (abs (- (abs old-guess) (abs new-guess))) (/ old-guess 10000000.0)))

  (defun sqrt-iter2 (new-guess old-guess x)
    (if (good-enough-improved? new-guess old-guess)
        new-guess
      (sqrt-iter2 (improve new-guess x) new-guess x)))

  (defun sqrt2 (x)
    (sqrt-iter2 1.0 x x))
#+end_src

My version seems to work much better for small numbers:
#+begin_src emacs-lisp
  (sqrt 0.00025) ;; => 0.033869844451165365
  ;;    bad!
  (sqrt2 0.00025) ;; => 0.015811388300841896
  ;;    As good as the built-in emacs lisp sqrt function!
#+end_src

But there doesn't seem to be no difference with big numbers:
#+begin_src emacs-lisp
  (sqrt 7894561230.0)  ;; 88851.34343385023
  (sqrt2 7894561230.0) ;; 88851.34343385023
#+end_src
This is so, I think, because, even if ~good-enough?~ returns ~nil~
when it shouldn't, ~improve~ is called until we get something that
differs from the radicant for less than 0.001... is this correct?

*** Exercise 1.8
Exercise:

#+begin_quote
Newton’s method for cube roots is based on the fact that if $y$ is an
approximation to the cube root of $x$, then a better approximation is
given by the value $\frac{x/y^2 + 2y}{3}$. Use this formula to
implement a cube-root procedure analogous to the square-root
procedure. (In 1.3.4 we will see how to implement Newton’s method in
general as an abstraction of these square-root and cube-root
procedures.)
#+end_quote

Answer: 

#+begin_src emacs-lisp
  (defun cuberoot (x)
    (cuberoot-iter2 1.0 x x))

  (defun cuberoot-iter (new-guess old-guess x)
    (if (good-enough-improved? new-guess old-guess)
        new-guess
      (cuberoot-iter2 (improve-cr new-guess x) new-guess x)))

  (defun improve-cr (guess x)
    (/ (+ (/ x (square guess))
          (* 2 y))
       3))


#+end_src
** 1.2 Procedures and the Processes They Generate
- Analogy with chess. Mastering the rules doesn't make you a master
  player. So far, we have only learnt the rules.
- To become expert programmers, we must learn to visualize the
  processes generated by various procedures. (Analogy with
  photography.)
- ``A procedure is a pattern for the /local evolution/ of a
  computational process''.
- Making statements about the /global/ behavior of a process (whose
  local evolution has been specified by a procedure) is a difficult
  task.
- We can try to describe some typical patterns of process evolution.
- In this section we will:
  - examine some common processes' ``shapes'';
  - investigate the rate at which these processes consume
    computational resources (space and time).
*** 1.2.1 Linear Recursion and Iteration
$n! = n \times (n - 1) \times (n - 1) \dots 3 \times 2 \times 1$

#+begin_export latex
$n! = n \times (n - 1) \times (n - 1) \dots 3 \times 2 \times 1$
#+end_export

One way to compute factorials:
#+begin_src scheme
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
#+end_src

Using the substitution model we can ``watch this procedure in
action'' (computing 6!):
#+begin_src scheme
  (factorial 6)
  (* 6 (factorial 5))
  (* 6 (* 5 (factorial 4)))
  (* 6 (* 5 (* 4 (factorial 3))))
  (* 6 (* 5 (* 4 (* 3 (factorial 2)))))
  (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
  (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
  (* 6 (* 5 (* 4 (* 3 2))))
  (* 6 (* 5 (* 4 6)))
  (* 6 (* 5 24))
  (* 6 120)
  720
#+end_src

Here is another way to compute the factorial:
#+begin_src scheme
  (define (factorial n) 
    (fact-iter 1 1 n))

  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
#+end_src

Let's ``visualize the process'' (of computing 6!):
#+begin_src scheme
  (factorial 6)
  (fact-iter 1 1 6)
  (fact-iter 1 1 6)
  (fact-iter 6 2 6)
  (fact-iter 12 3 6)
  (fact-iter 36 4 6)
  (fact-iter 144 5 6)
  (fact-iter 720 6 6)
  720
#+end_src

- Both processes:
  - compute the same mathematical function on the same domain;
  - require a number of steps proportional to ~n~ to compute ~n!~.

- However, we can notice a difference in ``shape'' between the ways
  the two processes evolve.
  - The first process is /recursive process/. Its evolutions shows
    /expansion/ and /contraction/. Expansion corresponds to /deferred
    operations/. Contraction corresponds to /performed
    operations/. The latter are to be kept track of. The amount of
    information we need to keep track of is proportionial to ~n~ ---
    it grows linearly with ~n~. This recursive process is therefore
    said to be /linear/.
  - The second process is an /iterative process/. The state of such a
    process can summarized in terms of a fixed number of state
    variables and the fixed rules to update those variables when
    moving from one state to the next one, and, optionally, the
    condition under which the process should terminate. We can see
    that the number of steps grows linearly with ~n~. This iterative
    process is therefore said to be /linear/.

- Another way to see the difference between the two processes: ``In
  the iterative case, the program variables provide a complete
  description of the state of the process at any point''. In the
  recursive case, some ``hidden information'' is maintained by the
  interpreter.

- Let's not confuse the notion of a recursive /process/ with that of a
  recursive /procedure/.

- Tail recursion.

*** Exercise 1.9
#+begin_quote
Each of the following two procedures defines a method for adding two
positive integers in terms of the procedures inc, which increments its
argument by 1, and dec, which decrements its argument by 1.

#+begin_src scheme
  (define (+ a b)
    (if (= a 0) 
        b 
        (inc (+ (dec a) b))))

  (define (+ a b)
    (if (= a 0) 
        b 
        (+ (dec a) (inc b))))
#+end_src

Using the substitution model, illustrate the process generated by each
procedure in evaluating (+ 4 5). Are these processes iterative or
recursive?
#+end_quote

#+begin_src scheme
  (+ 4 5)
  (inc (+ 3 5))
  (inc (inc (+ 2 5)))
  (inc (inc (inc (+ 1 5))))
  (inc (inc (inc (inc (+ 0 5)))))
  (inc (inc (inc (inc 5))))
  (inc (inc (inc 6)))
  (inc (inc 7))
  (inc 8)
  9
#+end_src
Judging by its shape, it looks like we are dealing with a recursive
process!

#+begin_src scheme
  (+ 4 5)
  (+ 3 6)
  (+ 2 7)
  (+ 1 8)
  (+ 0 9)
  9
#+end_src
Judging by its shape, it looks like we are dealing with an iterative
process!

*** Exercise 1.10
Exercise:
#+begin_quote
The following procedure computes a mathematical function called Ackermann’s function.

#+begin_src scheme
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+end_src
What are the values of the following expressions?

#+begin_src scheme
  (A 1 10)
  (A 2 4)
  (A 3 3)
#+end_src

Consider the following procedures, where A is the procedure defined above:
#+begin_src scheme
  (define (f n) (A 0 n))
  (define (g n) (A 1 n))
  (define (h n) (A 2 n))
  (define (k n) (* 5 n n))
#+end_src
Give concise mathematical definitions for the functions computed by
the procedures $f$, $g$, and $h$ for positive integer values of
$n$. For example, $(k n)$ computes $5n^2$.
#+end_quote

Answer:
#+begin_src scheme
  ;; let's see the evolution of (A 1 10):

  (A 1 10)

  (A 0 (A 1 9))

  (A 0 (A 0 (A 1 8)))

  (A 0 (A 0 (A 0 (A 1 7))))

  (A 0 (A 0 (A 0 (A 0 (A 1 6)))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 32)))))

  (A 0 (A 0 (A 0 (A 0 64))))

  (A 0 (A 0 (A 0 128)))

  (A 0 (A 0 256))

  (A 0 512)

  1024

  ;; We are looking at a recursive process. The answer is 1024.

#+end_src

#+begin_src scheme
  ;; Let's do the same with (A 2 4).

  (A 2 4)

  (A 1 (A 2 3))

  (A 1 (A 1 (A 2 2)))

  (A 1 (A 1 (A 1 (A 2 1))))

  (A 1 (A 1 (A 1 2)))

  (A 1 (A 1 (A 0 (A 1 1))))

  (A 1 (A 1 (A 0 2)))

  (A 1 (A 1 4))

  (A 1 (A 0 (A 1 3)))

  (A 1 (A 0 (A 0 (A 1 2))))

  (A 1 (A 0 (A 0 (A 0 (A 1 1)))))

  (A 1 (A 0 (A 0 (A 0 2))))

  (A 1 (A 0 (A 0 4)))

  (A 1 (A 0 8))

  (A 1 16)

  (A 0 (A 1 15))

  (A 0 (A 0 (A 1 14)))

  (A 0 (A 0 (A 0 (A 1 13))))

  (A 0 (A 0 (A 0 (A 0 (A 1 12)))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))

  (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))

  (A 0 (A 0 (A 0 (A 0 4096))))

  (A 0 (A 0 (A 0 8192)))

  (A 0 (A 0 16384))

  (A 0 32768)

  65536

  ;; interesting shape... the answer is 65536
#+end_src

#+begin_src scheme
  ;; Let's see now the evolution of (A 3 3):

  (A 3 3)

  (A 2 (A 3 2))

  (A 2 (A 2 (A 3 1)))

  (A 2 (A 2 2))

  (A 2 (A 1 (A 2 1)))

  (A 2 (A 1 2))

  (A 2 (A 0 (A 1 1)))

  (A 2 (A 0 2))

  (A 2 4) ;; We already know this one!

  65536
#+end_src

~(f 1)~ is 2:
#+begin_src scheme
  (f 1)

  (A 0 1)

  2
#+end_src

~(f 2)~ is 4:
#+begin_src scheme
  (f 2)

  (A 0 2)

  4
#+end_src

~(f 3)~ is 6:
#+begin_src scheme
  (f 3)

  (A 0 3)

  (A 6)
#+end_src

I conclude that ~(f n)~ computes $n \times 2$.

~(g 1)~ is 2:
#+begin_src scheme
  (g 1)

  (A 1 1)

  2
#+end_src

~(g 2)~ is 4:
#+begin_src scheme
  (g 2)

  (A 1 2)

  (A 0 (A 1 1))

  (A 0 2)

  4
#+end_src

~(g 3)~ is 8:
#+begin_src scheme
  (g 3)

  (A 1 3)

  (A 0 (A 1 2)) ;; we already know that (A 1 2) is 4

  (A 0 4)

  8
#+end_src

~(g 4)~ is 16:
#+begin_src scheme
  (g 4)

  (A 1 4)

  (A 0 (A 1 3)) ;; we already know that (A 1 3) is 8

  (A 0 8)

  16
#+end_src

Those are the powers of two. I conclude that ~(g n)~ computes $2^n$.


~(h 1)~ is 2:
#+begin_src scheme
  (h 1)

  (A 2 1)

  2
#+end_src

~(h 2)~ is 4:
#+begin_src scheme
  (h 2)

  (A 2 2)

  (A 1 (A 2 1))

  (A 1 2)

  (A 0 (A 1 1))

  (A 0 2)

  4
#+end_src

~(h 3)~ is 16:
#+begin_src scheme
  (h 3)

  (A 2 3)

  (A 1 (A 2 2))

  (A 1 (A 1 (A 2 1)))

  (A 1 (A 1 2))

  (A 1 (A 0 (A 1 1)))

  (A 1 (A 0 2))

  (A 1 4) ;; we already know that (A 1 4) is 16

  16
#+end_src

~(h 4)~ is 65536.
#+begin_src scheme
  (h 4)

  (A 2 4) ;; we know this one already...

  65536
#+end_src

~(h 5)~ is
#+begin_src scheme
  (h 5)

  (A 2 5)

  (A 1 (A 2 4)) ;; (A 2 4) is 65536

  (A 1 65536)

  (A 0 (A 1 65535))

  (A 0 (A 0 (A 1 65635))) ;; oh oh... this would take a while...
#+end_src

~(h 4)~ is $65536$, which is $2^{16}$. ~(h 3)~ is $16$, which is
$2^4$. ~(h 2)~ is $4$, which is $2^2$. My answer, then, is that ~(h
n)~ computes $n^{(h (1- n)))}$ where `(h (1- n))` is the application
of ~h~ to ~n~ minus 1.

*** 1.2.2 Tree Recursion
#+begin_src scheme
  (define (count-change amount)
    (cc amount 5))

  (define (cc amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins)))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))
#+end_src

- I wonder: what is an example of non-linear iteration?

*** Exercises 1.11
Exercise:

#+begin_quote
A function f is defined by the rule that $f(n) = n$ if $n <3 $ and
$f(n) = f(n−1) + 2f(n−2) + 3f(n−3)$ if $n \geq 3$. Write a procedure
that computes $f$ by means of a recursive process. Write a procedure
that computes $f$ by means of an iterative process.
#+end_quote

Answer:

Writing a procedure that computes ~f~ by means of a recursive process
is quite straightforward.
#+begin_src emacs-lisp
  (defun f (n)
    (cond
     ((< n 3) n)
     (t (+ (f (- n 1))
           (* 2 (f (- n 2)))
           (* 3 (f (- n 3)))))))

  (f 0)  ;; 0
  (f 1)  ;; 1
  (f 2)  ;; 2
  (f 3)  ;; 4
  (f 4)  ;; 11
  (f 5)  ;; 25
#+end_src

Writing a (recursive) procedure that computes ~f~ by means of an
iterative process is less straightforward.

My thought process: up to 2 we know the answer; the answer is the very
same input. For a number ~n~ greater than 2, we are able to compute
the answer if we know the result for the inputs ~n - 1~, ~n - 2~, and
~n - 3~. In the case of of number 3 --- the first number greater than
2 --- we do know the answer for the inputs 3-1, 3-2, and 3-3. They
are, respectively, 2, 1, and 0. Given that we know that we can compute
the value of the function given input 3: ....  But now we have the
enough knowledge to compute the value of the function given the
input 4. And once we know that... etc.

So we can use a counter that starts from 0 and iterate until we have
done the right number of ``loops'', keeping track of the three
relevant values that allows us to compute the value of the process at
that time.

#+begin_src emacs-lisp
  (defun f2 (n)
    (f-iter 0 n 0 1 2))

  (defun f-iter (counter max-count A B C)
    (if (< counter max-count) ;; keep iterating
        (if (< counter 3)
            (f-iter (1+ counter) max-count 0 1 2)
          (f-iter (1+ counter) max-count B C (+ (* 3 A)
                                                (* 2 B)
                                                C)))
      (if (< counter 3)
          counter
        (+ (* 3 A)
           (* 2 B)
           C))))

  (f2 0) ;; 0
  (f2 1) ;; 1
  (f2 2) ;; 2
  (f2 3) ;; 4
  (f2 4) ;; 11
  (f2 5) ;; 25
#+end_src

*** Exercise 1.12
Exercise:
#+begin_quote
....
#+end_quote

Answer:

Here is an iterative solution in js I could quickly come up with:

#+begin_src js
  function tartaglia(n) {
    let previousLine = [1, 1,];
    for (let i = 0; i < n; i++) {
      if (i == 0) {
        console.log( [1] )
      } else if (i == 1) {
        console.log( [1, 1] );
      } else {
        previousLine = line(previousLine);
        console.log(previousLine);
      }    
    }  
  }

  //Compute line given previous one
  function line(arr) {
    let result = [1, ];
    for (let i = 0; i < arr.length-1; i++) {
      result.push(arr[i] + arr[i+1]);
    }
    result.push(1);
    return result;
  }

  tartaglia(5);
  // =>
  // [ 1 ]
  // [ 1, 1 ]
  // [ 1, 2, 1 ]
  // [ 1, 3, 3, 1 ]
  // [ 1, 4, 6, 4, 1 ]
#+end_src

So... after too much thinking, while brushing my teeth and almost in
bed, I came up with a solution.

You can think of the triangle just as a bunch of lines/rows, each of
which is one element more than the previous one.

#+begin_src 
a
b, c
d, e, f
g, h, i, j
...
#+end_src

What helped me to find a solution was using a row[col] notation.
#+begin_src 
0[0]
1[0], 1[1]
2[0], 2[1], 2[2]
3[0], 3[1], 3[2], 3[3]
4[0], 4[1], 4[2], 4[3], 4[4]
#+end_src
We can immediately notice two things:
- first, col=0 means we are dealing with the first element of a
  row. But the first element of a row is always a 1.
- second, when row=col we are dealing with the last element of a
  row. But the last element of a row is always a 1.

Finally, we need a way to find the value of those elements where
neither row≠col nor col=0. Saying that an element equals the sum of
the two numbers ``above'' it is equivalent to say that an element with
inidex i at row r is equal to the sum of two elements at row r-1, more
specifically to the sum of those two elements the first one of which
has index i-1 and the second one of which has index i.

We have enough rules.
#+begin_src emacs-lisp
  ;;(tartaglia row col)
  ;;
  ;;col=0   ==> 1
  ;;col=row ==> 1
  ;;else    ==> (+ (tartaglia (1- row)(1- col))
  ;;               (tartaglia (1- row) col))
#+end_src

We can write our procedure!
#+begin_src emacs-lisp
  (defun tartaglia (r c)
    (cond
     ((= c 0) 1)
     ((= r c) 1)
     (t (+ (tartaglia (1- r)(1- c))
           (tartaglia (1- r) c)))))

  (tartaglia 0 0)
  ;; => 1
  (tartaglia 1 0) (tartaglia 1 1)
  ;; => 1, 1
  (tartaglia 2 0) (tartaglia 2 1) (tartaglia 2 2)
  ;; => 1, 2, 1
  (tartaglia 3 0) (tartaglia 3 1) (tartaglia 3 2) (tartaglia 3 3)
  ;; => 1, 3, 3, 1
  (tartaglia 4 0) (tartaglia 4 1) (tartaglia 4 2) (tartaglia 4 3) (tartaglia 4 4)
  ;; 1, 4, 6, 4, 1
#+end_src

It works!
*** 1.2.3 Orders of Growth
*** Exercise 1.14
Exercise:
#+begin_quote
Draw the tree illustrating the process generated by the count-change
procedure of 1.2.2 in making change for 11 cents. What are the orders
of growth of the space and number of steps used by this process as the
amount to be changed increases?
#+end_quote

Answer:
Here how the process looks like when using the substitution model:
#+begin_src emacs-lisp
  (defun count-change (amount)
    (cc amount 5))

  (defun cc (amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0) 
               (= kinds-of-coins 0)) 
           0)
          (t 
           (+ (cc amount (- kinds-of-coins 1))
              (cc (- amount (first-denomination 
                             kinds-of-coins))
                  kinds-of-coins)))))

  (defun first-denomination (kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (count-change 11)

  (count-change 11)

  (cc 11 5)

  (+ (cc 11 (- 5 1))
     (cc (- 11 (first-denomination 
                5))
         5))

  (+ (cc 11 4)
     (cc -39 5))

  (+ (cc 11 4)
     0)

  (+ (+ (cc 11 (- 4 1))
        (cc (- 11 (first-denomination 
                   4))
            4))
     0)

  (+ (+ (cc 11 3)
        (cc -14 4))
     0)

  (+ (+ (cc 11 3)
        0)
     0)

  (+ (+ (+ (cc 11 (- 3 1))
           (cc (- 11 (first-denomination 
                      3))
               3))
        0)
     0)

  (+ (+ (+ (cc 11 2)
           (cc 1 3))
        0)
     0)

  (+ (+ (+ (+ (cc 11 (- 2 1))
              (cc (- 11 (first-denomination 
                         2))
                  2))
           (+ (cc 1 (- 3 1))
              (cc (- 1 (first-denomination 
                        3))
                  3)))
        0)
     0)

  (+ (+ (+ (+ (cc 11 1)
              (cc 6 2))
           (+ (cc 1 2)
              (cc -9 3)))
        0)
     0)

  (+ (+ (+ (+ (cc 11 1)
              (cc 6 2))
           (+ (cc 1 2)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ (cc 11 (- 1 1))
                 (cc (- 11 (first-denomination 
                            1))
                     1))
              (+ (cc 6 (- 2 1))
                 (cc (- 6 (first-denomination 
                           2))
                     2)))
           (+ (+ (cc 1 (- 2 1))
                 (cc (- 1 (first-denomination 
                           2))
                     2))
              0))
        0)
     0)

  (+ (+ (+ (+ (+ (cc 11 0)
                 (cc 10 1))
              (+ (cc 6 1)
                 (cc 1 2)))
           (+ (+ (cc 1 1)
                 (cc -4 2))
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (cc 10 1))
              (+ (cc 6 1)
                 (cc 1 2)))
           (+ (+ (cc 1 1)
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ (cc 10 (- 1 1))
                    (cc (- 10 (first-denomination 
                               1))
                        1)))
              (+ (+ (cc 6 (- 1 1))
                    (cc (- 6 (first-denomination 
                              1))
                        1))
                 (+ (cc 1 (- 2 1))
                    (cc (- 1 (first-denomination 
                              2))
                        2))))
           (+ (+ (+ (cc 1 (- 1 1))
                    (cc (- 1 (first-denomination 
                              1))
                        1))
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ (cc 10 0)
                    (cc 9 1)))
              (+ (+ (cc 6 0)
                    (cc 5 1))
                 (+ (cc 1 1)
                    (cc -4 2))))
           (+ (+ (+ (cc 1 0)
                    (cc 0 1))
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (cc 9 1)))
              (+ (+ 0
                    (cc 5 1))
                 (+ (cc 1 1)
                    0)))
           (+ (+ (+ 0
                    1)
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (cc 9 1)))
              (+ (+ 0
                    (cc 5 1))
                 (+ (cc 1 1)
                    0)))
           (+ (+ 1
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ (cc 9 (- 1 1))
                       (cc (- 9 (first-denomination 
                                 1))
                           1))))
              (+ (+ 0
                    (+ (cc 5 (- 1 1))
                       (cc (- 5 (first-denomination 
                                 1))
                           1)))
                 (+ (+ (cc 1 (- 1 1))
                       (cc (- 1 (first-denomination 
                                 1))
                           1))
                    0)))
           (+ (+ 1
                 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ (cc 9 0)
                       (cc 8 1))))
              (+ (+ 0
                    (+ (cc 5 0)
                       (cc 4 1)))
                 (+ (+ (cc 1 0)
                       (cc 0 1))
                    0)))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (cc 8 1))))
              (+ (+ 0
                    (+ 0
                       (cc 4 1)))
                 (+ (+ 0 1)
                    0)))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (cc 8 1))))
              (+ (+ 0
                    (+ 0
                       (cc 4 1)))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ (cc 8 (- 1 1))
                          (cc (- 8 (first-denomination 
                                    1))
                              1)))))
              (+ (+ 0
                    (+ 0
                       (+ (cc 4 (- 1 1))
                          (cc (- 4 (first-denomination 
                                    1))
                              1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ (cc 8 (- 1 1))
                          (cc (- 8 1) 1)))))
              (+ (+ 0
                    (+ 0
                       (+ (cc 4 (- 1 1))
                          (cc (- 4 1) 1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ (cc 8 0)
                          (cc 7 1)))))
              (+ (+ 0
                    (+ 0
                       (+ (cc 4 0)
                          (cc 3 1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (cc 7 1)))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (cc 3 1))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (+ (cc 7 (- 1 1))
                               (cc (- 7 (first-denomination 
                                         1))
                                   1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (+ (cc 3 (- 1 1))
                               (cc (- 3 (first-denomination 
                                         1))
                                   1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (+ (cc 7 (- 1 1))
                               (cc (- 7 1)
                                   1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (+ (cc 3 (- 1 1))
                               (cc (- 3 1)
                                   1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 (+ (cc 7 0)
                               (cc 6 1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 (+ (cc 3 0)
                               (cc 2 1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (cc 6 1))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (cc 2 1)))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 6 (- 1 1))
                                  (cc (- 6 (first-denomination 
                                            1))
                                      1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 2 (- 1 1))
                                  (cc (- 2 (first-denomination 
                                            1))
                                      1))))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 6 (- 1 1))
                                  (cc (- 6 1)
                                      1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 2 (- 1 1))
                                  (cc (- 2 1)
                                      1))))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 6 0)
                                  (cc 5 1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 (+ (cc 2 0)
                                  (cc 1 1))))))
                 1))
           (+ (+ 1 0)
              0))
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (cc 5 1)))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (cc 1 1))))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 5 (- 1 1))
                                   (cc (- 5 (first-denomination 
                                             1))
                                       1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 1 (- 1 1))
                                   (cc (- 1 (first-denomination 
                                             1))
                                       1)))))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 5 (- 1 1))
                                   (cc (- 5 1)
                                       1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 1 (- 1 1))
                                   (cc (- 1 1)
                                       1)))))))
                 1))
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 5 0)
                                   (cc 4 1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ (cc 1 0)
                                   (cc 0 1)))))))
                 1))
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (cc 4 1))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0 1))))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ (cc 4 (- 1 1))
                                      (cc (- 4 (first-denomination 
                                                1))
                                          1)))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0 1)))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ (cc 4 (- 1 1))
                                      (cc (- 4 1)
                                          1)))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 1))))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ (cc 4 0)
                                      (cc 3 1)))))))))
              (+ (+ 0
                    (+ 0
                       (+ 0 1)))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (cc 3 1)))))))))
              (+ (+ 0
                    (+ 0 1))
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ (cc 3 (- 1 1))
                                         (cc (- 3 (first-denomination 
                                                   1))
                                             1))))))))))
              (+ (+ 0 1)
                 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ (cc 3 (- 1 1))
                                         (cc (- 3 1)
                                             1))))))))))
              (+ 1 1))
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ (cc 3 0)
                                         (cc (- 3 1)
                                             1))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (cc 2 1))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ (cc 2 (- 1 1))
                                            (cc (- 2 (first-denomination 
                                                      1))
                                                1)))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ (cc 2 (- 1 1))
                                            (cc (- 2 1)
                                                1)))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ (cc 2 0)
                                            (cc 1 1)))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ (cc 1 (- 1 1))
                                               (cc (- 1 (first-denomination 
                                                         1))
                                                   1))))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ (cc 1 (- 1 1))
                                               (cc (- 1 1)
                                                   1))))))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ (cc 1 0)
                                               (cc 0 1))))))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0
                                            (+ 0 1)))))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0
                                         (+ 0 1))))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0
                                      (+ 0 1)))))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0
                                   (+ 0 1))))))))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0
                                (+ 0 1)))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0
                             (+ 0 1))))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0
                          (+ 0 1)))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0
                       (+ 0 1))))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0
                 (+ 0
                    (+ 0 1)))
              2)
           1)
        0)
     0)

  (+ (+ (+ (+ (+ 0
                 (+ 0 1))
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ (+ 0 1)
              2)
           1)
        0)
     0)


  (+ (+ (+ (+ 1 2)
           1)
        0)
     0)


  (+ (+ (+ 3 1)
        0)
     0)


  (+ (+ 4 0)
     0)


  (+ 4 0)

  4
#+end_src

Analogously to what has been done at page 38 with ~fib~, we can
represent tree generated by ~count-change~ in the following way:
#+begin_src
                                                            (count-change 11)
                                                               (cc 11 5)
                                                               /       \
                                                       (cc 11 4)      (cc - 39 5)
                                                       /      \             \
                                                  (cc 11 3)  (cc -14 4)      0
                                                   /      \         \
                                              (cc 11 2)  (cc 1 3)    0
                                              /     \      /     \
                                     (cc 11 1) (cc 6 2) (cc 1 2) (cc -9 3)
                                     ___|      /\____     |_____          \
                                 ___/   |     |      |    |____ \_______   \_____
                                |       |     |       \        |        |        |
                        (cc 11 0) (cc 10 1) (cc 6 1) (cc 1 2) (cc 1 1) (cc -4 2) 0
                        ___/   ____/ |         /\        |\         |_________    \__________
                  _____/   ___|     /         /  \       | \_____   \_______  |______        |
                 |        |        /         /   |       |       |          |        |       |
                 0 (cc 10 0) (cc 9 1) (cc 6 0) (cc 5 1) (cc 1 1) (cc -4 2) (cc 1 0) (cc 0 1) 0
                      /       /\        /      / \         |\____     \       |      |
                   __/     __/  \      /      /   \        |     \___  \_____ |      |
                  |       /      |    |      /     \       |         |      | |      |
                  0 (cc 9 0) (cc 8 1) 0 (cc 5 0) (cc 4 1) (cc 1 0) (cc 0 1) 0 0      1         
                      |          /\          |        |\__       \   |
                      |         /  \         |        |   \       \  |
                      0  (cc 8 0)  (cc 7 1)  0  (cc 4 0) (cc 3 1) 0  1
                          |          /\          |          /\     
                          |         /  \         |         /  \
                          0  (cc 7 0)  (cc 6 1)  0  (cc 3 0)  (cc 2 1)
                               |          /\          |          /\
                               |         /  \         |         /  \
                               0  (cc 6 0)  (cc 5 1)  0  (cc 2 0)  (cc 1 1)
                                   /        /\           /         /\
                                  /        /  \         |         /  \
                                 0  (cc 5 0)  (cc 4 1)  0  (cc 1 0) (cc 0 1)
                                      |          /\           |        |
                                      |         /  \          |        |
                                      0  (cc 4 0)  (cc 3 1)   0        1
                                            |           /\
                                            |          /  \
                                            0   (cc 3 0)  (cc 2 1)
                                                   |           /\ 
                                                   |          /  \
                                                   0   (cc 2 0)  (cc 1 1)
                                                          |           /\
                                                          |          /  \ 
                                                          0   (cc 1 0)  (cc 0 1)
                                                                  |        |
                                                                  0        1  
#+end_src
This looks like a tree recursive processe like that of ~fib~. And
#+begin_quote
In general, the number of steps required by a tree-recursive process
will be proportional to the number of nodes in the tree, while the
space required will be proportional to the maximum depth of the tree
(p.39).
#+end_quote

So the order of growth in time of ~count-change~ is $\Theta(n^2)$ and
the order of growth in space is $\Theta(n)$. Is it? (I had a look at
solutions online and I see that the situation might be more complex
than I thought.)

*** Exercise 1.15
Exercise:
#+begin_quote
The sine of an angle (specified in radians) can be computed by making
use of the approximation $\sin x \approx x$if $x$ is sufficiently
small, and the trigonometric identity

$\sin x = 3 \sin \frac{x}{3} - 4 \sin^3 \frac{x}{3}$

to reduce the size of the argument of $\sin$. (For purposes of this
exercise an angle is considered ``sufficiently small'' if its
magnitude is not greater than 0.1 radians.) These ideas are
incorporated in the following procedures:

#+begin_src scheme
  (define (cube x) (* x x x))
  (define (p x) (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))
#+end_src

1. How many times is the procedure p applied when ~(sine 12.15)~ is
   evaluated?
2. What is the order of growth in space and number of steps (as a
   function of ~a~) used by the process generated by the ~sine~
   procedure when ~(sine a)~ is evaluated?
#+end_quote

Answer:
#+begin_src emacs-lisp
  (defun cube (x) (* x x x))
  (defun p (x) (- (* 3 x) (* 4 (cube x))))
  (defun sine (angle)
    (if (not (> (abs angle) 0.1))
        angle
      (p (sine (/ angle 3.0)))))
#+end_src

#+begin_src emacs-lisp
  (defun cube (x) (* x x x))
  (defun p (x) (- (* 3 x) (* 4 (cube x))))
  (defun sine (angle)
    (if (not (> (abs angle) 0.1))
        angle
      (p (sine (/ angle 3.0)))))


  (sine 12.15) ;; -0.39980345741334
  (p (sine (/ 12.15 3.0)))
  (p (sine 4.05))
  (p (p (sine (/ 4.05 3.0))))
  (p (p (sine 1.3499999999999999)))
  (p (p (p (sine (/ 1.3499999999999999 3.0)))))
  (p (p (p (sine 0.44999999999999996))))
  (p (p (p (p (sine (/ 0.44999999999999996 3.0))))))
  (p (p (p (p (sine 0.15)))))
  (p (p (p (p (p (sine (/ 0.15 3.0)))))))
  (p (p (p (p (p (sine 0.049999999999999996))))))
  (p (p (p (p (p (sine 0.049999999999999996))))))
  (p (p (p (p (p 0.049999999999999996)))))
  (p (p (p (p (- (* 3 0.049999999999999996) (* 4 (cube 0.049999999999999996)))))))
  (p (p (p (p 0.1495))))
  (p (p (p 0.4351345505)))
  (p (p 0.9758465331678772))
  (p -0.7895631144708228)
  (- -2.3686893434124685 -1.9688858859991285)
  -0.39980345741334  
#+end_src
1. Procedure ~p~ is applied five times.

2. I tentatively thought that the order of growth in space and time
   was O(n).

   However I've looked arout at other people's solutions and that is
   not right. The order of growth is better than linear; it's
   logarithmic, O(log(n)); more specifically O(log3(n)). I
   definitively need to revive my math skills, assuming they still
   exist somewhere.

   This was the most intuitive explanation I've found of why that is
   so: ``the amount of times ~p~ is evaluated is incremented by one
   for every tripling of ~a~. [...] As for the order of growth
   regarding space, it should be the same as for the number of steps,
   because for each additional step, there is exactly one more
   function call that the system must keep track of''
   (https://www.timwoerner.de/posts/sicp/exercises/1/15/)
*** 1.2.4 Exponentiation
$b^n = b \times b^(n-1)$, and $b^0 = 1$.  Translating this into a
procedure:
#+begin_src emacs-lisp
  (defun expt (b n)
    (if (= n 0)
        1
      (* b (expt b (- n 1)))))
#+end_src
This requires  ϴ(n) steps and  ϴ(n) space.

We have have already seen such a kind of process (linear recursion)
with factorial. JUst as with factorial, we can write a procedurs that
evolves a linear iterative process:

#+begin_src emacs-lisp
  (defun expt-iter (b counter product)
    (if (= counter 0)
        product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
#+end_src
This process requires ϴ(n) steps and ϴ(1) space.

We can be faster. 
#+begin_src emacs-lisp
  (defun fast-expt (b n)
    (cond ((= n 0)
           1)
          ((even? n)
           (square (fast-expt b (/ n 2))))
          (t
           (* b (fast-expt b (- n 1))))))

  (defun (even? n)
      (= (remainder n 2) 0))
#+end_src
~fast-expt~ evolves a process that grows /logarithmically/ with n in
both space and time.
*** Exercise 1.16
Exercise:
#+begin_quote
Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does ~fast-expt~. (Hint: Using the observation that $(b^{b/2})^2 =
(b^2)^{n/2}$, keep, along with the exponent n and the base b, an
additional state variable a, and define the state transformation in
such a way that the product abn is unchanged from state to state. At
the beginning of the process a is taken to be 1, and the answer is
given by the value of a at the end of the process. In general, the
technique of defining an invariant quantity that remains unchanged
from state to state is a powerful way to think about the design of
iterative algorithms.)
#+end_quote

Answer:
#+begin_src emacs-lisp
  (defun fast-expt-i (b n)
    (fast-expt-iter b n 1))

  (defun fast-expt-iter (b n a)
    (cond ((= n 0) a)
          ((even n)
           (fast-expt-iter (square b) (/ n 2) a))
          (t
           (fast-expt-iter b (- n 1) (* b a)))))
#+end_src

I've asked ChatGPT about whether it thought that this solution was
correct. Here is the answer:
#+begin_quote
Yes, the provided implementation of the fast-expt-i function and the
fast-expt-iter function appears to correctly compute the value of the
exponentiation with base b and exponent n.

The fast-expt-i function is a wrapper function that calls the
fast-expt-iter function with the initial value of a set to 1. The
fast-expt-iter function is a recursive function that implements the
exponentiation algorithm using a technique called "iterative
deepening," which allows for more efficient computation of
exponentiation by repeatedly squaring the base and halving the
exponent until the exponent becomes 0.

The cond statement in the fast-expt-iter function handles the base
case where the exponent is 0, as well as the cases where the exponent
is even or odd. In the case where the exponent is 0, the function
returns the value of a, which is the result of the exponentiation. In
the case where the exponent is even, the function calls itself with
the square of the base and half the exponent, and in the case where
the exponent is odd, the function calls itself with the base and the
exponent decremented by 1.

Overall, the provided implementation appears to correctly compute the
value of the exponentiation with base b and exponent n.
#+end_quote

I've also asked about space complexity:
#+begin_quote
The order of growth in space of the fast-expt-i function is O(n),
where n is the value of the exponent. This is because the function
uses recursive calls to compute the exponentiation, and each recursive
call requires additional space on the call stack to store the local
variables and intermediate results.

In the case of the fast-expt-i function, the space required for each
recursive call is constant, as it only stores the values of the base
b, exponent n, and accumulator a variables. Therefore, the total space
required by the function is proportional to the number of recursive
calls, which is equal to the value of the exponent.

For example, if the exponent has a value of n, the function will
require O(n) space to compute the result, as it will make n recursive
calls. This is known as linear space complexity.

It is important to note that the space complexity of the fast-expt-i
function can be improved by using a technique called "tail call
optimization," which allows the compiler to reuse the space on the
call stack for the recursive calls, rather than allocating additional
space for each call. This can reduce the space complexity of the
function to O(1), as only a constant amount of space is required to
store the local variables and intermediate results. However, this
optimization is not performed by default in most Lisp implementations,
and may require explicit support from the compiler or runtime
environment.
#+end_quote

*** Exercise 1.17
#+begin_quote
The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way,
one can perform integer multiplication by means of repeated
addition. The following multiplication procedure (in which it is
assumed that our language can only add, not multiply) is analogous to
the expt procedure:
#+begin_src scheme
  (define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+end_src
This algorithm takes a number of steps that is linear in b. Now
suppose we include, together with addition, operations double, which
doubles an integer, and halve, which divides an (even) integer
by 2. Using these, design a multiplication procedure analogous to
fast-expt that uses a logarithmic number of steps.
#+end_quote

Answer:
#+begin_src emacs-lisp
  (defun double (a)
    (* a 2))

  (defun halve (a)
    (/ a 2))

  (defun fast-* (a b)
    (cond ((= b 1) a)
          ((even b) (double (fast-* a (halve b))))
          (t (+ a (fast-* a (- b 1))))))
#+end_src

*** Exercise 1.18
Exercise:
#+begin_quote
Using the results of Exercise 1.16 and Exercise 1.17, devise a
procedure that generates an iterative process for multiplying two
integers in terms of adding, doubling, and halving and uses a
logarithmic number of steps (fn: This algorithm, which is sometimes
known as the “Russian peasant method” of multiplication, is
ancient. Examples of its use are found in the Rhind Papyrus, one of
the two oldest mathematical documents in existence, written about 1700
B.C. (and copied from an even older document) by an Egyptian scribe
named A’h-mose.)
#+end_quote

Answer
#+begin_src emacs-lisp
  (defun fast-*-i (a b)
    (fast-*-iter a b 0))

  (defun fast-*-iter (a b c)
    (cond ((= c 0) 0)
          ((even b) (fast-*-iter (double a) (halve b) c))
          (t (fast-*-iter a (- b 1) (+ a c))
#+end_src

*** Exercise 1.19
#+begin_quote
There is a clever algorithm for computing the Fibonacci numbers in a
logarithmic number of steps. Recall the transformation of the state
variables a and b in the fib-iter process of 1.2.2: $a \leftarrow a +
b$ and $b \leftarrow a$. Call this transformation $T$, starting with
the pair (1, 0). Now consider $T$ to be the special case of $p = 0$
and $q = 1$ in a family of transformation $T_{pq}$, where $T_{pq}$
transforms the pair $(a, b)$ according to $a \leftarrow bq + aq + ap$
and $b \leftarrow bp + aq$. Show that if we apply such a
transformation $T_{pq}$ twice, the effect is the same as using a
single transformation $T_{p'q'}$ of the same form, and computer $p'$
and $q'$ in terms of $p$ and $q$. This gives us an explicit way to
square these transformations, and thus we can compute $T^n$ using
successive squaring, as in the ~fast-expt~ procedures. Put this all
together to complete the following procedure, which runs in a
logarithmic number of steps:
#+end_quote

#+begin_src scheme
  (define (fib n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0) 
           b)
          ((even? count)
           (fib-iter a
                     b
                     ⟨??⟩  ;compute p'
                     ⟨??⟩  ;compute q'
                     (/ count 2)))
          (else 
           (fib-iter (+ (* b q) 
                        (* a q) 
                        (* a p))
                     (+ (* b p) 
                        (* a q))
                     p
                     q
                     (- count 1)))))

#+end_src

*** 1.2.5 Greatest Common Divisors
Exercise:
#+begin_quote
Exercise 1.20: The process that a procedure generates is of course
dependent on the rules used by the interpreter. As an example,
consider the iterative gcd procedure given above. Suppose we were to
interpret this procedure using normal-order evaluation, as discussed
in 1.1.5. (The normal-order-evaluation rule for if is described in
Exercise 1.5.) Using the substitution method (for normal order),
illustrate the process generated in evaluating (gcd 206 40) and
indicate the remainder operations that are actually performed. How
many remainder operations are actually performed in the normal-order
evaluation of (gcd 206 40)? In the applicative-order evaluation?
#+end_quote

Answer:

Let us repeat some older stuff.

*Evaluation a combination (applicative order)*: The interpreter
evaluates a combination by:
1. Evaluating the subexpression of the combination (recursion!);
2. Applying the procedure that is the value of the leftmost
   subexpression (the operator) to the arguments that are the values
   of the other subexpressions (the operands).


What does it mean to apply a procedure?

*Procedure application*: for primitive procedures we can assume that
the mechanism is built into the interpreter. For compound procedurees:
evaluate the body of the procedure with each formal parameter
*replaced* by the corresponding argument. Given the replacing this is
known as ``substitution model''.

A different model:

*Evaluation a combination (normal order evaluation)*: evaluate the
operan only when needed

#+begin_src emacs-lisp
  (defun gcd (a b)
    (if (= b 0)
        a
      (gcd b (% a b))))
#+end_src

#+begin_src emacs-lisp
  ;; normal order evaluation

  (gcd 206 40)
  (if (= 40 0)
      206
    (gcd 40 (% 206 40)))

  (gcd 40 (% 206 40)))
  (if (= (% 206 40) 0) ;;1
      40
    (gcd (% 206 40) (% 40 (% 206 40))))

  (gcd (% 206 40) (% 40 (% 206 40)))
  (if (= (% 40 (% 206 40)) 0) ;; 2, 3
      (% 206 40)
    (gcd (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))

  (gcd (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40))))
  (if (= (% (% 206 40) (% 40 (% 206 40))) 0) ;; 4, 5, 6, 7
      (% 40 (% 206 40))
    (gcd (% (% 206 40) (% 40 (% 206 40)))
         (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))))

  (gcd (% (% 206 40) (% 40 (% 206 40)))
       (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))
  (if (= (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))) 0) ;; 8, 9, 10, 11, 12, 13, 14
        (% (% 206 40) (% 40 (% 206 40)))
      (gcd (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40))))
           (% (% (% 206 40) (% 40 (% 206 40))) (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))))

  (% (% 206 40) (% 40 (% 206 40))) ;; 15, 16, 17, 18
#+end_src


#+begin_src emacs-lisp
  ;; applicative order evaluation
  (defun gcd (a b)
    (if (= b 0)
        a
      (gcd b (% a b))))

  (gcd 206 40)
  (if (= 40 0)
      206
    (gcd 40 (% 206 40)))

  (gcd 40 (% 206 40)) ; 1
  (gcd 40 6)
  (if (= 6 0)
      40
    (gcd 6 (% 40 6)))

  (gcd 6 (% 40 6)) ; 2
  (gcd 6 4)
  (if (= 4 0)
      6
    (gcd 4 (% 6 4)))

  (gcd 4 (% 6 4)) ; 3
  (gcd 4 2)
  (if (= 2 0)
      4
    (gcd 2 (% 4 2)))

  (gcd 2 (% 4 2)) ; 4
  (gcd 2 0)
  (if (= 0 0)
      2
    (gcd 0 (% 2 0)))

  2
#+end_src

*** 1.2.6 Example: Testing for Primality
Here is one way to find whether a number is prime:
#+begin_src emacs-lisp
  (defun smallest-divisor (n)
    (find-divisor n 2))

  (defun find-divisor (n test-divisor)
    (cond ((> (square test-divisor) n)
           n)
          ((dividesp test-divisor n)
           test-divisor)
          (t (find-divisor
              n
              (+ test-divisor 1)))))

  (defun dividesp (a b)
    (= (% b a ) 0))

  (defun primep (n)
    (= n (smallest-divisor n)))
#+end_src

In the worst case scenario we have to call test-divisor $\sqrt{n}$
times. So, the order of growth is $\Theta (\sqrt{n})$.


The authors also present a $\Theta (log(n))$ algorithm to tests
primality. It is based on the so-called Fermat's Little Theorem.

- Fermat's Little Theorem: If $n$ is a prime number and $a$ is any
  positive integer less than n, then $a$ raised ot the $n^{th}$ power
  is congruent to $a$ modulo $n$.

#+begin_src emacs-lisp
  (defun expmod (base exp m)
    (cond ((= exp 0) 1)
          ((evenp exp)
           (%
            (square (expmod base (/ exp 2) m))
            m))
          (t
           (%
            (* base (expmod base (- exp 1) m))
            m))))

  (defun try-it (a n)
    (= (expmod a n n) a))

  (defun fermat-test (n)
    (try-it (+ 1 (random (- n 1))) n))

  (defun fast-primep (n times)
    (cond ((= times 0) t)
          ((fermat-test n)
           (fast-primep n (- times 1)))
          (t nil)))

  (defun evenp (n)
    (= (% n 2) 0)
#+end_src
*** ex 1.21
Exercise:
#+begin_quote
Use the smallest-divisor procedure to find the smallest divisor of
each of the following numbers: 199, 1999, 19999.
#+end_quote

Answer:
#+begin_src emacs-lisp
  (smallest-divisor 199)   ;; => 199
#+end_src

This is the series of procedure calls:
#+begin_src emacs-lisp
  (smallest-divisor 199)
  (find-divisor 199 2)
  (cond ((> (square 2) 199)
         199)
        ((dividesp 2 199)
         2)
        (t (find-divisor
            199
            (+ 2 1))))
  (find-divisor 199 3)
  (find-divisor 199 4)
  (find-divisor 199 5)
  (find-divisor 199 6)
  (find-divisor 199 7)
  (find-divisor 199 8)
  (find-divisor 199 9)
  (find-divisor 199 10)
  (find-divisor 199 11)
  (find-divisor 199 12)
  (find-divisor 199 13)
  (find-divisor 199 14)
  (find-divisor 199 15)
  199
#+end_src


#+begin_src emacs-lisp
  (smallest-divisor 1999)  ;; => 1999
#+end_src

This is the series of procedure calls:
#+begin_src emacs-lisp
  (smallest-divisor 1999)
  (find-divisor 1999 2)

  (cond ((> (square 2) 1999)
         1999)
        ((dividesp 2 1999)
         2)
        (t (find-divisor
               1999
               (+ 2 1))))

  (find-divisor 1999 3)

  (find-divisor 1999 4)

  ;; ...

  (find-divisor 1999 45)

  1999
#+end_src



#+begin_src emacs-lisp
  (smallest-divisor 19999) ;; => 7
#+end_src
This is the series of procedure calls:
#+begin_src emacs-lisp
  (smallest-divisor 19999)

  (find-divisor 19999 2)

  (find-divisor 19999 3)

  (find-divisor 19999 4)

  (find-divisor 19999 5)

  (find-divisor 19999 6)

  (find-divisor 19999 7)
  7
#+end_src
*** ex 1.22
#+begin_quote
Most Lisp implementations include a primitive called runtime that
returns an integer that specifies the amount of time the system has
been running (measured, for example, in microseconds). The following
timed-prime-test procedure, when called with an integer n, prints n
and checks to see if n is prime. If n is prime, the procedure prints
three asterisks followed by the amount of time used in performing the
test.

#+begin_src scheme
  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))
  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) 
                         start-time))))
  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
#+end_src

Using this procedure, write a procedure search-for-primes that checks
the primality of consecutive odd integers in a specified range. Use
your procedure to find the three smallest primes larger than 1000;
larger than 10,000; larger than 100,000; larger than 1,000,000. Note
the time needed to test each prime. Since the testing algorithm has
order of growth of $\theta (\sqrt{n})$, you should expect that testing
for primes around 10,000 should take about $\sqrt{10}$ times as long
as testing for primes around 1000. Do your timing data bear this out?
How well do the data for 100,000 and 1,000,000 support the $\theta
(\sqrt{n})$ prediction? Is your result compatible with the notion that
programs on your machine run in time proportional to the number of
steps required for the computation?
#+end_quote


Answer:

For this one I'm using (Dr)Racket, which provides a version of Scheme
specifically modified in order to be used for SICP's code (useful here
in that it provides ~runtime~).

#+begin_src scheme
  #lang sicp
  (define (square x)
    (* x x))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) 
           n)
          ((divides? test-divisor n) 
           test-divisor)
          (else (find-divisor 
                 n 
                 (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) 
                         start-time))))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

  (timed-prime-test 199) ;; 199 *** 6
#+end_src

#+begin_src scheme
  (define (search-for-primes begin end)
    (cond ((< begin end)
           (timed-prime-test begin)
           (search-for-primes (+ 2 begin) end))))
#+end_src

#+begin_src scheme
  (search-for-primes 1001 1021)
  ;; 1001
  ;; 1003
  ;; 1005
  ;; 1007
  ;; 1009 *** 5
  ;; 1011
  ;; 1013 *** 4
  ;; 1015
  ;; 1017
  ;; 1019 *** 3

  (search-for-primes 10001 10050)
  ;; 10001
  ;; 10003
  ;; 10005
  ;; 10007 *** 12
  ;; 10009 *** 9
  ;; 10011
  ;; 10013
  ;; 10015
  ;; 10017
  ;; 10019
  ;; 10021
  ;; 10023
  ;; 10025
  ;; 10027
  ;; 10029
  ;; 10031
  ;; 10033
  ;; 10035
  ;; 10037 *** 8
  ;; 10039 *** 8
  ;; 10041
  ;; 10043
  ;; 10045
  ;; 10047
  ;; 10049

  (search-for-primes 100001 100050)
  ;; 100001
  ;; 100003 *** 22
  ;; 100005
  ;; 100007
  ;; 100009
  ;; 100011
  ;; 100013
  ;; 100015
  ;; 100017
  ;; 100019 *** 21
  ;; 100021
  ;; 100023
  ;; 100025
  ;; 100027
  ;; 100029
  ;; 100031
  ;; 100033
  ;; 100035
  ;; 100037
  ;; 100039
  ;; 100041
  ;; 100043 *** 21
  ;; 100045
  ;; 100047
  ;; 100049 *** 20

  (search-for-primes 1000001 1000051)

  ;; 1000001
  ;; 1000003 *** 79
  ;; 1000005
  ;; 1000007
  ;; 1000009
  ;; 1000011
  ;; 1000013
  ;; 1000015
  ;; 1000017
  ;; 1000019
  ;; 1000021
  ;; 1000023
  ;; 1000025
  ;; 1000027
  ;; 1000029
  ;; 1000031
  ;; 1000033 *** 63
  ;; 1000035
  ;; 1000037 *** 62
  ;; 1000039 *** 65
  ;; 1000041
  ;; 1000043
  ;; 1000045
  ;; 1000047
  ;; 1000049
#+end_src



# #+begin_quote
# you should expect that testing for primes around 10,000 should take
# about $\sqrt{10}$ times as long as testing for primes around 1000. Do
# your timing data bear this out?
# #+end_quote
# The numbers after 1000 took 5, 4, 3. The numbers after 10000 took 12,
# 9 and 8. (I don't know why time decreases with bigger numbers).

# Now, (* 5 (sqrt 10)) 15 something, (* 4 (sqrt 10)) is 12 something, (*
# 3 (sqrt 10)) is 9 something. So, yeah, more or less...


# #+begin_quote
# How well do the data for 100,000 and 1,000,000 support the $\theta
# (\sqrt{n})$ prediction?
# #+end_quote

# The numbers after 100000 took 22 and 21. The numbers after 1000001
# took 79, 63, and 62.

# (* 22 (sqrt 10)) is 69 something. (* 21 (sqrt 10)) is 66 something. So
# yeah, again, more or less...

# #+begin_quote
# Is your result compatible with the notion that programs on your
# machine run in time proportional to the number of steps required for
# the computation?
# #+end_quote
# I don't see why not.

In today's computers these operations take microseconds. I have been
told that the accuracy of these measurements is not to be trusted,
given the small size of these amounts of time.

We can, however, use biggers numbers.

Computing ~(timed-prime-test 34888314291653)~ --- I've chosen randomly
--- took 642.775 milliseconds. These should be more than enough to
have an acceptable accuracy in our benchmarking. Let's start our
experiments from here.

Let's find the first three primes starting from 34888314291653.

#+begin_src scheme
  ;; 34888314291653 *** 701102
  ;; 34888314291655
  ;; 34888314291657
  ;; 34888314291659
  ;; 34888314291661
  ;; 34888314291663
  ;; 34888314291665
  ;; 34888314291667 *** 895322
  ;; 34888314291669
  ;; 34888314291671
  ;; 34888314291673
  ;; 34888314291675
  ;; 34888314291677
  ;; 34888314291679
  ;; 34888314291681
  ;; 34888314291683
  ;; 34888314291685
  ;; 34888314291687
  ;; 34888314291689
  ;; 34888314291691
  ;; 34888314291693
  ;; 34888314291695
  ;; 34888314291697
  ;; 34888314291699
  ;; 34888314291701
  ;; 34888314291703
  ;; 34888314291705
  ;; 34888314291707
  ;; 34888314291709
  ;; 34888314291711
  ;; 34888314291713 *** 630255
#+end_src

Now we multiply 34888314291653 by ten and find the first three primes
starting from there. 34888314291653 times 10 is 348883142916530.

#+begin_src scheme
  ;; 348883142916531
  ;; 348883142916533 *** 2027795
  ;; 348883142916535
  ;; 348883142916537
  ;; 348883142916539
  ;; 348883142916541
  ;; 348883142916543
  ;; 348883142916545
  ;; 348883142916547
  ;; 348883142916549
  ;; 348883142916551
  ;; 348883142916553
  ;; 348883142916555
  ;; 348883142916557
  ;; 348883142916559
  ;; 348883142916561
  ;; 348883142916563
  ;; 348883142916565
  ;; 348883142916567
  ;; 348883142916569
  ;; 348883142916571
  ;; 348883142916573
  ;; 348883142916575
  ;; 348883142916577
  ;; 348883142916579
  ;; 348883142916581
  ;; 348883142916583
  ;; 348883142916585
  ;; 348883142916587
  ;; 348883142916589
  ;; 348883142916591
  ;; 348883142916593
  ;; 348883142916595
  ;; 348883142916597
  ;; 348883142916599
  ;; 348883142916601
  ;; 348883142916603
  ;; 348883142916605
  ;; 348883142916607
  ;; 348883142916609
  ;; 348883142916611
  ;; 348883142916613 *** 1893341
  ;; 348883142916615
  ;; 348883142916617
  ;; 348883142916619
  ;; 348883142916621
  ;; 348883142916623
  ;; 348883142916625
  ;; 348883142916627
  ;; 348883142916629
  ;; 348883142916631
  ;; 348883142916633
  ;; 348883142916635
  ;; 348883142916637
  ;; 348883142916639
  ;; 348883142916641
  ;; 348883142916643
  ;; 348883142916645
  ;; 348883142916647
  ;; 348883142916649
  ;; 348883142916651
  ;; 348883142916653
  ;; 348883142916655
  ;; 348883142916657
  ;; 348883142916659
  ;; 348883142916661
  ;; 348883142916663
  ;; 348883142916665
  ;; 348883142916667
  ;; 348883142916669
  ;; 348883142916671
  ;; 348883142916673
  ;; 348883142916675
  ;; 348883142916677
  ;; 348883142916679
  ;; 348883142916681
  ;; 348883142916683
  ;; 348883142916685
  ;; 348883142916687
  ;; 348883142916689
  ;; 348883142916691
  ;; 348883142916693
  ;; 348883142916695
  ;; 348883142916697
  ;; 348883142916699
  ;; 348883142916701
  ;; 348883142916703
  ;; 348883142916705
  ;; 348883142916707
  ;; 348883142916709
  ;; 348883142916711
  ;; 348883142916713
  ;; 348883142916715
  ;; 348883142916717
  ;; 348883142916719
  ;; 348883142916721
  ;; 348883142916723
  ;; 348883142916725
  ;; 348883142916727
  ;; 348883142916729
  ;; 348883142916731
  ;; 348883142916733
  ;; 348883142916735
  ;; 348883142916737
  ;; 348883142916739 *** 1809663
#+end_src

(* 701102 (sqrt 10)) = 2217079.192099371. With 348883142916533 we
took 2027795, so the prediction is roughly correct.


Let us now test whether the number we find after (*
10 348883142916530) and those after (* 10 10 348883142916530) fulfill
the prediction too.

#+begin_quote
3488831429165323 *** 5971326
#+end_quote

#+begin_src scheme
  (search-for-primes 3488831429165301 3488831429165401)
  ;; ...
  ;; 3488831429165323 *** 5971326
  ;; ...
#+end_src

#+begin_src scheme
  (search-for-primes 34888314291653011 34888314291653511)
  ;; ...
  ;; 34888314291653021 *** 16052655
  ;; ...
#+end_src

(* 5971326 (sqrt 10)) 18882990.81138261. Again, the prediction seems
roughly correct.

*** ex 1.23
#+begin_quote
The ~smallest-divisor~ procedure shown at the start of this section
does lots of needless testing: After it checks to see if the number is
divisible by 2 there is no point in checking to see if it is divisible
by any larger even numbers. This suggests that the values used for
~test-divisor~ should not be 2, 3, 4, 5, 6, …, but rather 2, 3, 5, 7,
9, …. To implement this change, define a procedure next that returns 3
if its input is equal to 2 and otherwise returns its input
plus 2. Modify the ~smallest-divisor~ procedure to use ~(next
test-divisor)~ instead of ~(+ test-divisor 1)~. With
~timed-prime-test~ incorporating this modified version of
~smallest-divisor~, run the test for each of the 12 primes found in
Exercise 1.22. Since this modification halves the number of test
steps, you should expect it to run about twice as fast. Is this
expectation confirmed? If not, what is the observed ratio of the
speeds of the two algorithms, and how do you explain the fact that it
is different from 2?
#+end_quote



*** ex 1.25
- check fn 46

* Skipped exercises
List of the exercises I have skipped:
- Exercise 1.13, p. 42.
- Exersise 1.19, p. ?
